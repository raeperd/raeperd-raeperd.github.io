<!doctype html><html lang=korean dir=auto>
<head><meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name=robots content="index, follow">
<title>NearCall and FarCall | raeperd.github.io</title>
<meta name=keywords content="assembly">
<meta name=description content="Motivation 어셈블리 레벨에서 프로그램을 분석할 때, CALL 명령은 매우 중요한 역할을 한다. 실행 중인 프로그램의 실행 순서는 CALL 이나 JMP 와 같은 흐름을 제어하는 명령을 만나지 않는다면 기본적으로 순차적으로 진행된다. CALL 은 이런 프로그램의 진행 흐름을 변경하는 명령문으로 프로그램의 흐름을 따라가려면 당연하게도 CALL 명령어의 흐름을 따라갈 수 있어야한다.
printf 함수를 어셈블리 레벨에서 볼 일이 있었는데, 그 과정에서 알게된 사실을 기록해둔다.
 CONTENTS prtinf 함수의 본모습 printf 함수는 어셈블리 레벨에서 아래와 같은 코드로 구성되어 있다.">
<meta name=author content="raeperd">
<link rel=canonical href=https://raeperd.github.io/notes/programming/assembly/near-call-vs-far-call/>
<link href=/assets/css/stylesheet.min.css rel="preload stylesheet" as=style>
<link rel=icon href=https://raeperd.github.io/favicon.ico>
<link rel=icon type=image/png sizes=16x16 href=https://raeperd.github.io/favicon-16x16.png>
<link rel=icon type=image/png sizes=32x32 href=https://raeperd.github.io/favicon-32x32.png>
<link rel=apple-touch-icon href=https://raeperd.github.io/apple-touch-icon.png>
<link rel=mask-icon href=https://raeperd.github.io/safari-pinned-tab.svg>
<meta name=theme-color content="#2e2e33">
<meta name=msapplication-TileColor content="#2e2e33">
<meta name=generator content="Hugo 0.86.1">
<script type=application/javascript>var doNotTrack=!1;doNotTrack||(window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga('create','UA-168674186-1','auto'),ga('send','pageview'))</script>
<script async src=https://www.google-analytics.com/analytics.js></script>
<meta property="og:title" content="NearCall and FarCall">
<meta property="og:description" content="Motivation 어셈블리 레벨에서 프로그램을 분석할 때, CALL 명령은 매우 중요한 역할을 한다. 실행 중인 프로그램의 실행 순서는 CALL 이나 JMP 와 같은 흐름을 제어하는 명령을 만나지 않는다면 기본적으로 순차적으로 진행된다. CALL 은 이런 프로그램의 진행 흐름을 변경하는 명령문으로 프로그램의 흐름을 따라가려면 당연하게도 CALL 명령어의 흐름을 따라갈 수 있어야한다.
printf 함수를 어셈블리 레벨에서 볼 일이 있었는데, 그 과정에서 알게된 사실을 기록해둔다.
 CONTENTS prtinf 함수의 본모습 printf 함수는 어셈블리 레벨에서 아래와 같은 코드로 구성되어 있다.">
<meta property="og:type" content="article">
<meta property="og:url" content="https://raeperd.github.io/notes/programming/assembly/near-call-vs-far-call/"><meta property="og:image" content="https://raeperd.github.io/papermod-cover.png"><meta property="article:section" content="notes">
<meta property="article:published_time" content="2019-10-25T00:00:00+00:00">
<meta property="article:modified_time" content="2019-10-25T00:00:00+00:00"><meta property="og:site_name" content="raeperd.github.io">
<meta name=twitter:card content="summary_large_image">
<meta name=twitter:image content="https://raeperd.github.io/papermod-cover.png">
<meta name=twitter:title content="NearCall and FarCall">
<meta name=twitter:description content="Motivation 어셈블리 레벨에서 프로그램을 분석할 때, CALL 명령은 매우 중요한 역할을 한다. 실행 중인 프로그램의 실행 순서는 CALL 이나 JMP 와 같은 흐름을 제어하는 명령을 만나지 않는다면 기본적으로 순차적으로 진행된다. CALL 은 이런 프로그램의 진행 흐름을 변경하는 명령문으로 프로그램의 흐름을 따라가려면 당연하게도 CALL 명령어의 흐름을 따라갈 수 있어야한다.
printf 함수를 어셈블리 레벨에서 볼 일이 있었는데, 그 과정에서 알게된 사실을 기록해둔다.
 CONTENTS prtinf 함수의 본모습 printf 함수는 어셈블리 레벨에서 아래와 같은 코드로 구성되어 있다.">
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Notes","item":"https://raeperd.github.io/notes/"},{"@type":"ListItem","position":2,"name":"NearCall and FarCall","item":"https://raeperd.github.io/notes/programming/assembly/near-call-vs-far-call/"}]}</script>
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"NearCall and FarCall","name":"NearCall and FarCall","description":"Motivation 어셈블리 레벨에서 프로그램을 분석할 때, CALL 명령은 매우 중요한 역할을 한다. 실행 중인 프로그램의 실행 순서는 CALL 이나 JMP 와 같은 흐름을 제어하는 명령을 만나지 않는다면 기본적으로 순차적으로 진행된다. CALL 은 이런 프로그램의 진행 흐름을 변경하는 명령문으로 프로그램의 흐름을 따라가려면 당연하게도 CALL 명령어의 흐름을 따라갈 수 있어야한다.\nprintf 함수를 어셈블리 레벨에서 볼 일이 있었는데, 그 과정에서 알게된 사실을 기록해둔다.\n CONTENTS prtinf 함수의 본모습 printf 함수는 어셈블리 레벨에서 아래와 같은 코드로 구성되어 있다.","keywords":["assembly"],"articleBody":"Motivation 어셈블리 레벨에서 프로그램을 분석할 때, CALL 명령은 매우 중요한 역할을 한다. 실행 중인 프로그램의 실행 순서는 CALL 이나 JMP 와 같은 흐름을 제어하는 명령을 만나지 않는다면 기본적으로 순차적으로 진행된다. CALL 은 이런 프로그램의 진행 흐름을 변경하는 명령문으로 프로그램의 흐름을 따라가려면 당연하게도 CALL 명령어의 흐름을 따라갈 수 있어야한다.\nprintf 함수를 어셈블리 레벨에서 볼 일이 있었는데, 그 과정에서 알게된 사실을 기록해둔다.\n CONTENTS prtinf 함수의 본모습 printf 함수는 어셈블리 레벨에서 아래와 같은 코드로 구성되어 있다.\n _printf: 00401050: 55 push ebp 00401051: 8B EC mov ebp,esp 00401053: 83 EC 08 sub esp,8 00401056: 8D 45 0C lea eax,[ebp+0Ch] 00401059: 89 45 FC mov dword ptr [ebp-4],eax 0040105C: 8B 4D FC mov ecx,dword ptr [ebp-4] 0040105F: 51 push ecx 00401060: 6A 00 push 0 00401062: 8B 55 08 mov edx,dword ptr [ebp+8] 00401065: 52 push edx 00401066: 6A 01 push 1 00401068: FF 15 AC 20 40 00 CALL dword ptr [__imp____acrt_iob_func] 0040106E: 83 C4 04 add esp,4 00401071: 50 push eax 00401072: E8 A9 FF FF FF CALL __vfprintf_l 00401077: 83 C4 10 add esp,10h 0040107A: 89 45 F8 mov dword ptr [ebp-8],eax 0040107D: C7 45 FC 00 00 00 00 mov dword ptr [ebp-4],0 00401084: 8B 45 F8 mov eax,dword ptr [ebp-8] 00401087: 8B E5 mov esp,ebp 00401089: 5D pop ebp 0040108A: C3 ret 0040108B: CC CC CC CC CC 두번의 CALL 명령을 각각 00401068, 00401072 주소에서 확인 할 수 있다.\n자세히 보아야 확인할 수 있는데 두 CALL 명령어는 다른 기계어를 가지고 있다. 첫번째 CALL 명령어는 FF15 ~ 로 시작하는 반면 두번째 CALL 명령어는 E8~ 로 시작하는 것을 알 수 있다. 원래 CALL 명령은 당연히 E8 명령이라고 생각했는데 다른 기계어를 같은 어셈블리로 해석하는 것처럼 보여 머리에 쥐가 나기 시작했다. 그래서 이것저것 공부해본 것을 정리해 본다.\nNear Call and Far Call 프로그램이 함수를 호출할때, 현재의 주소를 스택에 저장하고 IP(Instruction Pointer)를 다음 함수의 호출 주소로 변경하면서 실행흐름을 변경한다. 함수 호출간의 인자를 어떻게 전달하고, 복귀 주소를 어떻게 저장하는지도 중요한 주제지만, 이번 글에서는 IP 가 어떻게 변경될 수 있는지에 대해 더 자세하게 알아보려 한다.\nCALL 명령의 인자로 전달 될 수 있는 값은 상수, 레지스터, 메모리 주소가 있다. 함수 호출에는 크게 다음과 같이 4가지 종류가 있다.\n Near Call  현재 code segment 내의 주소로의 CALL (CS register가 가리키고 있는 segment)   Far Call  다른 code segement 주소로의 CALL   Inter-privilege-level far call  다른 권한을 가지고 있는 code segment 주소로의 Far Call   Task switch  다른 task에 존재하는 주소로의 CALL    가장 아래의 두 CALL 은 protected mode 에서만 호출 될 수 있는 CALL 이다. 오늘의 관심사는 첫 두 콜에 대한 얘기가 될 것.\n Near Call Near Call은 일반적으로 우리가 알고있는 함수 호출 과정이 이루어 진다. 프로세서는 IP를 스택에 push 하고, CALL 명령의 operand의 주소로 실행 흐름을 변경한다. 이때 operand 로 올 수 있는 값은 1. code segment로 부터의 offset (absolute) 과 2. 현재 IP의 값으로 부터의 offset (relative), 두가지를 가질 수 있다.\n operand가 code segment 로 부터의 offset 인 경우 (absolute) 이 경우 offset 은 메모리주소나 레지스터등을 통해 간접적으로 주어진다. 몇 bit 프로세서냐에 따라 operand의 크기는 달라지는데, 만약 64-bit 프로세서인 경우 offset 은 강제적으로 64 bit 에 맞춰진다. 곧 absolute offset 은 EIP(RIP) 레지스터에 바로 load 된다.\noperand가 IP 로부터의 offset 인 경우 (relative) 이 경우 일반적으로 어셈블리 코드에서는 label 을 확인할 수 있다. (위 예의 경우 원래 명령어는 E8 A9 FF FF FF 이지만 어셈블리에서는 CALL __vfprintf_l 와 같이 함수 이름을 확인할 수 있다.) 하지만 기계어 레벨에서는 부호가 있는 16 혹은 32-bit 값으로 해석된다. 64-bit 프로세서의 경우 operand의 크기는 32-bit 크기로 고정이고, 이 값은 RIP 와 연산되기 이전에 64-bit 로 확장되어 연산된다.\n Far Call Far Call의 경우 포로세서는 IP와 함께 CS 레지스터의 값도 스택에 push 한다. 이후 다른 code segment의 주소로 실행흐름을 변경해야하기 때문에 Near Call 보다 전달 받아야하는 인자가 많다. 이때 operand는 pointer 를 이용한 절대적인 주소일 수도 있고 double pointer를 통한 간접적인 주소일 수도 있다.\npointer를 사용하는 방법의 경우 4바이트(16-bit)나 6바이트(32-bit)의 주소를 operand로 전달받는다.\nFar Call 의 경우 더 많은 케이스가 있는데 더 자세한 케이스는 여기에서 확인할 수 있다.\n 그래서 왜 FF15 도 CALL이죠? FF 의 비밀 결국 CALL 도 내가 알고 있던것 보다 더 많은 종류가 필요했고, 당연히 프로세서가 알아먹을려면 다른 명령어로 명령을 전달해야한다. 그런 이유에서 E8 외에도 다양한 명령이 필요한데, 가능한 명령은 아래와 같다.\n   Opcode Mnemonic Description     E8 cw CALL rel16 Call near, relative, displacement relative to next instruction   E8 cd CALL rel32 Call near, relative, displacement relative to next instruction   FF /2 CALL r/m16 Call near, absolute indirect, address given in r/m16   FF /2 CALL r/m32 Call near, absolute indirect, address given in r/m32   9A cd CALL ptr16:16 Call far, absolute, address given in operand   9A cp CALL ptr16:32 Call far, absolute, address given in operand   FF /3 CALL m16:16 Call far, absolute , address given in m16:16   FF /3 CALL m16:32 Call far, absolute indirect, address given in m16:32    FF 명령이 있는걸 확인할 수 있다 ! E8 과 구체적으로는 다른 명령어지만 비슷한 역할을 하기 때문에 dumpbin 은 그냥 같은 CALL 로 해석을 한 것 같다. 하지만 아직 FF 뒤의 한 바이트 0x15 는 이해하지 못했다.\n 0x15 바이트의 비밀 FF로 시작하는 명령어는 INC, DEC, CALLN, CALLF, JMPN, JMPF, PUSH 가 있다. FF 뒤의 한 바이트는 특정한 규칙을 따르는데, 0x15를 통해 예를 보자.\n0x15는 바이너리로 표현하면 0001 0101 이 된다. 5번째 비트 부터 010 인데 이는 10진수로 2다. 이는 명령어 집합 {INC, DEC, CALLN, CALLF, JMPN, JMPF, PUSH} 중 3번째 원소를 택해야한다는 것을 의미한다. (인덱스가 0번부터 시작해서 2번 인덱스가 3번째 원소가 된다. 배열처럼!)\n결국 CALLN 을 얻게 되는데, 이때의 N은 Near를 의미한다! 결국 FF15 는 간접호출 이면서, Near Call 을 의미하는 명령어 였던 것이다 !\n 결론 다하고 나니까 이걸 왜했나 싶기도 한데 재밌었다! 역시 컴퓨터를 만든사람은 어지간히 똑똑한게 아니구나 싶었고 이런 고민도 결국 누군가가 이미 했구나는 생각이 든다. 본 글의 대부분도 StackOverflow 나 다른 블로그에서 본 글을 정리한것에 지나지 않는다.\n아주 완벽하게 모든걸 이해한 것은 아니지만 (Far Call의 다른 호출이 어떤식으로 이루어지는지, 64비트와 32비트 프로세서가 어떻게 다르게 동작하는지 등) 이정도 이해하고 만족하고 넘어가려 한다. 나중에 더 궁금해지면 그때 다시 알아보면 된다.\nReference  Why call instruction opcode is represented as FF15? | Stack Overflow\n How can I tell if jump is absolute or relative? X86-64 Instruction Encoding | Stack Overflow\n x86 Instruction Set Reference\n x86 Instruction Set Reference - Call Procedure\n","wordCount":"1003","inLanguage":"korean","datePublished":"2019-10-25T00:00:00Z","dateModified":"2019-10-25T00:00:00Z","author":{"@type":"Person","name":"raeperd"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://raeperd.github.io/notes/programming/assembly/near-call-vs-far-call/"},"publisher":{"@type":"Organization","name":"raeperd.github.io","logo":{"@type":"ImageObject","url":"https://raeperd.github.io/favicon.ico"}}}</script>
</head>
<body id=top>
<script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script>
<noscript>
<style type=text/css>#theme-toggle,.top-link{display:none}</style>
<style>@media(prefers-color-scheme:dark){:root{--theme:#1d1e20;--entry:#2e2e33;--primary:rgba(255, 255, 255, 0.84);--secondary:rgba(255, 255, 255, 0.56);--tertiary:rgba(255, 255, 255, 0.16);--content:rgba(255, 255, 255, 0.74);--hljs-bg:#2e2e33;--code-bg:#37383e;--border:#333}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style>
</noscript>
<header class=header>
<nav class=nav>
<div class=logo>
<a href=https://raeperd.github.io/ accesskey=h title="raeperd.github.io (Alt + H)">raeperd.github.io</a>
<span class=logo-switches>
<button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg>
</button>
</span>
</div>
<ul id=menu onscroll=menu_on_scroll()>
<li>
<a href=https://raeperd.github.io/articles title=Article>
<span>Article</span>
</a>
</li>
<li>
<a href=https://raeperd.github.io/notes title=Note>
<span>Note</span>
</a>
</li>
<li>
<a href=https://raeperd.github.io/search title="Search (Alt + /)" accesskey=/>
<span>Search</span>
</a>
</li>
<li>
<a href=https://raeperd.github.io/archives/ title=Archives>
<span>Archives</span>
</a>
</li></ul>
</nav>
</header>
<main class=main><article class=post-single>
<header class=post-header>
<h1 class=post-title>
NearCall and FarCall
</h1>
<div class=post-meta>
October 25, 2019&nbsp;·&nbsp;raeperd
</div>
<br>
<ul class=post-tags>
<li><a href=https://raeperd.github.io/tags/assembly/>assembly</a></li>
</ul>
</header>
<div class=post-content>
<h1 id=motivation>Motivation<a hidden class=anchor aria-hidden=true href=#motivation>#</a></h1>
<p>어셈블리 레벨에서 프로그램을 분석할 때, <code>CALL</code> 명령은 매우 중요한 역할을 한다. 실행 중인 프로그램의 실행 순서는 <code>CALL</code> 이나 JMP 와 같은 흐름을 제어하는 명령을 만나지 않는다면 기본적으로 순차적으로 진행된다. <code>CALL</code> 은 이런 프로그램의 진행 흐름을 변경하는 명령문으로 프로그램의 흐름을 따라가려면 당연하게도 <code>CALL</code> 명령어의 흐름을 따라갈 수 있어야한다.</p>
<p>printf 함수를 어셈블리 레벨에서 볼 일이 있었는데, 그 과정에서 알게된 사실을 기록해둔다.</p>
<p> </p>
<h1 id=contents>CONTENTS<a hidden class=anchor aria-hidden=true href=#contents>#</a></h1>
<h2 id=prtinf-함수의-본모습>prtinf 함수의 본모습<a hidden class=anchor aria-hidden=true href=#prtinf-함수의-본모습>#</a></h2>
<p><code>printf</code> 함수는 어셈블리 레벨에서 아래와 같은 코드로 구성되어 있다.</p>
<pre><code> _printf:
   00401050: 55                   push        ebp
   00401051: 8B EC                mov         ebp,esp
   00401053: 83 EC 08             sub         esp,8
   00401056: 8D 45 0C             lea         eax,[ebp+0Ch]
   00401059: 89 45 FC             mov         dword ptr [ebp-4],eax
   0040105C: 8B 4D FC             mov         ecx,dword ptr [ebp-4]
   0040105F: 51                   push        ecx
   00401060: 6A 00                push        0
   00401062: 8B 55 08             mov         edx,dword ptr [ebp+8]
   00401065: 52                   push        edx
   00401066: 6A 01                push        1
   00401068: FF 15 AC 20 40 00    CALL        dword ptr [__imp____acrt_iob_func]
   0040106E: 83 C4 04             add         esp,4
   00401071: 50                   push        eax
   00401072: E8 A9 FF FF FF       CALL        __vfprintf_l
   00401077: 83 C4 10             add         esp,10h
   0040107A: 89 45 F8             mov         dword ptr [ebp-8],eax
   0040107D: C7 45 FC 00 00 00 00 mov         dword ptr [ebp-4],0
   00401084: 8B 45 F8             mov         eax,dword ptr [ebp-8]
   00401087: 8B E5                mov         esp,ebp
   00401089: 5D                   pop         ebp
   0040108A: C3                   ret
   0040108B: CC CC CC CC CC
</code></pre><p>두번의 <code>CALL</code> 명령을 각각 <em>00401068</em>, <em>00401072</em> 주소에서 확인 할 수 있다.</p>
<p>자세히 보아야 확인할 수 있는데 두 <code>CALL</code> 명령어는 다른 기계어를 가지고 있다. 첫번째 <code>CALL</code> 명령어는 FF15 ~ 로 시작하는 반면 두번째 <code>CALL</code> 명령어는 E8~ 로 시작하는 것을 알 수 있다. 원래 <code>CALL</code> 명령은 당연히 E8 명령이라고 생각했는데 다른 기계어를 같은 어셈블리로 해석하는 것처럼 보여 머리에 쥐가 나기 시작했다. 그래서 이것저것 공부해본 것을 정리해 본다.</p>
<h2 id=near-call-and-far-call><strong>Near Call and Far Call</strong><a hidden class=anchor aria-hidden=true href=#near-call-and-far-call>#</a></h2>
<p>프로그램이 함수를 호출할때, 현재의 주소를 스택에 저장하고 IP(Instruction Pointer)를 다음 함수의 호출 주소로 변경하면서 실행흐름을 변경한다. 함수 호출간의 인자를 어떻게 전달하고, 복귀 주소를 어떻게 저장하는지도 중요한 주제지만, 이번 글에서는 IP 가 어떻게 변경될 수 있는지에 대해 더 자세하게 알아보려 한다.</p>
<p>CALL 명령의 인자로 전달 될 수 있는 값은 상수, 레지스터, 메모리 주소가 있다. 함수 호출에는 크게 다음과 같이 4가지 종류가 있다.</p>
<ul>
<li>Near Call
<ul>
<li>현재 code segment 내의 주소로의 CALL (CS register가 가리키고 있는 segment)</li>
</ul>
</li>
<li>Far Call
<ul>
<li>다른 code segement 주소로의 CALL</li>
</ul>
</li>
<li>Inter-privilege-level far call
<ul>
<li>다른 권한을 가지고 있는 code segment 주소로의 Far Call</li>
</ul>
</li>
<li>Task switch
<ul>
<li>다른 task에 존재하는 주소로의 CALL</li>
</ul>
</li>
</ul>
<p>가장 아래의 두 CALL 은 protected mode 에서만 호출 될 수 있는 CALL 이다. 오늘의 관심사는 첫 두 콜에 대한 얘기가 될 것.</p>
<p> </p>
<h3 id=near-call><strong>Near Call</strong><a hidden class=anchor aria-hidden=true href=#near-call>#</a></h3>
<p>Near Call은 일반적으로 우리가 알고있는 함수 호출 과정이 이루어 진다. 프로세서는 IP를 스택에 push 하고, CALL 명령의 operand의 주소로 실행 흐름을 변경한다. 이때 operand 로 올 수 있는 값은 <strong>1. code segment로 부터의 offset (absolute)</strong> 과 <strong>2. 현재 IP의 값으로 부터의 offset (relative)</strong>, 두가지를 가질 수 있다.</p>
<p> </p>
<h3 id=operand가-code-segment-로-부터의-offset-인-경우-absolute>operand가 code segment 로 부터의 offset 인 경우 (absolute)<a hidden class=anchor aria-hidden=true href=#operand가-code-segment-로-부터의-offset-인-경우-absolute>#</a></h3>
<p>이 경우 offset 은 메모리주소나 레지스터등을 통해 간접적으로 주어진다. 몇 bit 프로세서냐에 따라 operand의 크기는 달라지는데, 만약 64-bit 프로세서인 경우 offset 은 강제적으로 64 bit 에 맞춰진다. 곧 absolute offset 은 EIP(RIP) 레지스터에 바로 load 된다.</p>
<h3 id=operand가-ip-로부터의-offset-인-경우-relative>operand가 IP 로부터의 offset 인 경우 (relative)<a hidden class=anchor aria-hidden=true href=#operand가-ip-로부터의-offset-인-경우-relative>#</a></h3>
<p>이 경우 일반적으로 어셈블리 코드에서는 label 을 확인할 수 있다. (위 예의 경우 원래 명령어는 <code>E8 A9 FF FF FF</code> 이지만 어셈블리에서는 <code>CALL __vfprintf_l</code> 와 같이 함수 이름을 확인할 수 있다.) 하지만 기계어 레벨에서는 부호가 있는 16 혹은 32-bit 값으로 해석된다. 64-bit 프로세서의 경우 operand의 크기는 32-bit 크기로 고정이고, 이 값은 RIP 와 연산되기 이전에 64-bit 로 확장되어 연산된다.</p>
<p> </p>
<h3 id=far-call><strong>Far Call</strong><a hidden class=anchor aria-hidden=true href=#far-call>#</a></h3>
<p>Far Call의 경우 포로세서는 IP와 함께 CS 레지스터의 값도 스택에 push 한다. 이후 다른 code segment의 주소로 실행흐름을 변경해야하기 때문에 Near Call 보다 전달 받아야하는 인자가 많다. 이때 operand는 pointer 를 이용한 절대적인 주소일 수도 있고 double pointer를 통한 간접적인 주소일 수도 있다.</p>
<p>pointer를 사용하는 방법의 경우 4바이트(16-bit)나 6바이트(32-bit)의 주소를 operand로 전달받는다.</p>
<p>Far Call 의 경우 더 많은 케이스가 있는데 더 자세한 케이스는
<a href=https://c9x.me/x86/html/file_module_x86_id_26.html target=_blank>여기</a>에서 확인할 수 있다.</p>
<p> </p>
<h2 id=그래서-왜-ff15-도-call이죠>그래서 왜 FF15 도 CALL이죠?<a hidden class=anchor aria-hidden=true href=#그래서-왜-ff15-도-call이죠>#</a></h2>
<h3 id=ff-의-비밀><strong>FF 의 비밀</strong><a hidden class=anchor aria-hidden=true href=#ff-의-비밀>#</a></h3>
<p>결국 CALL 도 내가 알고 있던것 보다 더 많은 종류가 필요했고, 당연히 프로세서가 알아먹을려면 다른 명령어로 명령을 전달해야한다. 그런 이유에서 E8 외에도 다양한 명령이 필요한데, 가능한 명령은 아래와 같다.</p>
<table>
<thead>
<tr>
<th>Opcode</th>
<th>Mnemonic</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>E8 cw</td>
<td>CALL rel16</td>
<td>Call near, relative, displacement relative to next instruction</td>
</tr>
<tr>
<td>E8 cd</td>
<td>CALL rel32</td>
<td>Call near, relative, displacement relative to next instruction</td>
</tr>
<tr>
<td>FF /2</td>
<td>CALL r/m16</td>
<td>Call near, absolute indirect, address given in r/m16</td>
</tr>
<tr>
<td>FF /2</td>
<td>CALL r/m32</td>
<td>Call near, absolute indirect, address given in r/m32</td>
</tr>
<tr>
<td>9A cd</td>
<td>CALL ptr16:16</td>
<td>Call far, absolute, address given in operand</td>
</tr>
<tr>
<td>9A cp</td>
<td>CALL ptr16:32</td>
<td>Call far, absolute, address given in operand</td>
</tr>
<tr>
<td>FF /3</td>
<td>CALL m16:16</td>
<td>Call far, absolute , address given in m16:16</td>
</tr>
<tr>
<td>FF /3</td>
<td>CALL m16:32</td>
<td>Call far, absolute indirect, address given in m16:32</td>
</tr>
</tbody>
</table>
<p>FF 명령이 있는걸 확인할 수 있다 ! E8 과 구체적으로는 다른 명령어지만 비슷한 역할을 하기 때문에 dumpbin 은 그냥 같은 CALL 로 해석을 한 것 같다. 하지만 아직 FF 뒤의 한 바이트 0x15 는 이해하지 못했다.</p>
<p> </p>
<h3 id=0x15-바이트의-비밀><strong>0x15 바이트의 비밀</strong><a hidden class=anchor aria-hidden=true href=#0x15-바이트의-비밀>#</a></h3>
<p>FF로 시작하는 명령어는 <code>INC</code>, <code>DEC</code>, <code>CALLN</code>, <code>CALLF</code>, <code>JMPN</code>, <code>JMPF</code>, <code>PUSH</code> 가 있다. FF 뒤의 한 바이트는 특정한
<a href=http://wiki.osdev.org/X86-64_Instruction_Encoding#ModR.2FM target=_blank>규칙</a>을 따르는데, 0x15를 통해 예를 보자.</p>
<p>0x15는 바이너리로 표현하면 <code>0001 0101</code> 이 된다. 5번째 비트 부터 <code>010</code> 인데 이는 10진수로 2다. 이는 명령어 집합 {<code>INC</code>, <code>DEC</code>, <code>CALLN</code>, <code>CALLF</code>, <code>JMPN</code>, <code>JMPF</code>, <code>PUSH</code>} 중 3번째 원소를 택해야한다는 것을 의미한다. (인덱스가 0번부터 시작해서 2번 인덱스가 3번째 원소가 된다. 배열처럼!)</p>
<p>결국 <code>CALLN</code> 을 얻게 되는데, 이때의 N은 Near를 의미한다! 결국 <code>FF15</code> 는 간접호출 이면서, Near Call 을 의미하는 명령어 였던 것이다 !</p>
<p> </p>
<h1 id=결론><strong>결론</strong><a hidden class=anchor aria-hidden=true href=#결론>#</a></h1>
<p>다하고 나니까 이걸 왜했나 싶기도 한데 재밌었다! 역시 컴퓨터를 만든사람은 어지간히 똑똑한게 아니구나 싶었고 이런 고민도 결국 누군가가 이미 했구나는 생각이 든다. 본 글의 대부분도 StackOverflow 나 다른 블로그에서 본 글을 정리한것에 지나지 않는다.</p>
<p>아주 완벽하게 모든걸 이해한 것은 아니지만 (Far Call의 다른 호출이 어떤식으로 이루어지는지, 64비트와 32비트 프로세서가 어떻게 다르게 동작하는지 등) 이정도 이해하고 만족하고 넘어가려 한다. 나중에 더 궁금해지면 그때 다시 알아보면 된다.</p>
<h1 id=reference><strong>Reference</strong><a hidden class=anchor aria-hidden=true href=#reference>#</a></h1>
<p>
<a href=https://stackoverflow.com/questions/29837363/why-call-instruction-opcode-is-represented-as-ff15 target=_blank>Why call instruction opcode is represented as FF15? | Stack Overflow</a></p>
<p>
<a href=https://stackoverflow.com/questions/31544052/how-can-i-tell-if-jump-is-absolute-or-relative target=_blank>How can I tell if jump is absolute or relative?</a>
<a href=https://wiki.osdev.org/X86-64_sInstruction_Encoding#ModR.2FM target=_blank>X86-64 Instruction Encoding | Stack Overflow</a></p>
<p>
<a href=https://c9x.me/x86/ target=_blank>x86 Instruction Set Reference</a></p>
<p>
<a href=https://c9x.me/x86/html/file_module_x86_id_26.html target=_blank>x86 Instruction Set Reference - Call Procedure</a></p>
</div>
<footer class=post-footer>
<div class=share-buttons>
<a target=_blank rel="noopener noreferrer" aria-label="share NearCall and FarCall on twitter" href="https://twitter.com/intent/tweet/?text=NearCall%20and%20FarCall&url=https%3a%2f%2fraeperd.github.io%2fnotes%2fprogramming%2fassembly%2fnear-call-vs-far-call%2f&hashtags=assembly"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share NearCall and FarCall on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fraeperd.github.io%2fnotes%2fprogramming%2fassembly%2fnear-call-vs-far-call%2f&title=NearCall%20and%20FarCall&summary=NearCall%20and%20FarCall&source=https%3a%2f%2fraeperd.github.io%2fnotes%2fprogramming%2fassembly%2fnear-call-vs-far-call%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share NearCall and FarCall on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fraeperd.github.io%2fnotes%2fprogramming%2fassembly%2fnear-call-vs-far-call%2f&title=NearCall%20and%20FarCall"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share NearCall and FarCall on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fraeperd.github.io%2fnotes%2fprogramming%2fassembly%2fnear-call-vs-far-call%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share NearCall and FarCall on whatsapp" href="https://api.whatsapp.com/send?text=NearCall%20and%20FarCall%20-%20https%3a%2f%2fraeperd.github.io%2fnotes%2fprogramming%2fassembly%2fnear-call-vs-far-call%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share NearCall and FarCall on telegram" href="https://telegram.me/share/url?text=NearCall%20and%20FarCall&url=https%3a%2f%2fraeperd.github.io%2fnotes%2fprogramming%2fassembly%2fnear-call-vs-far-call%2f"><svg viewBox="2 2 28 28"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg>
</a>
</div>
</footer><div id=disqus_thread></div>
<script>(function(){var a=document,b=a.createElement('script');b.src='https://raeperd-github-io.disqus.com/embed.js',b.setAttribute('data-timestamp',+new Date),(a.head||a.body).appendChild(b)})()</script>
<noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript>
</article>
</main><footer class=footer>
<span>&copy; 2021 <a href=https://raeperd.github.io/>raeperd.github.io</a></span>
<span>&#183;</span>
<span>Powered by <a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a></span>
<span>&#183;</span>
<span>Theme <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span>
</footer>
<a href=#top aria-label="go to top" title="Go to Top (Alt + G)">
<button class=top-link id=top-link type=button accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</button>
</a>
<script defer src=/assets/js/highlight.min.js onload=hljs.initHighlightingOnLoad()></script>
<script>window.onload=function(){localStorage.getItem("menu-scroll-position")&&(document.getElementById('menu').scrollLeft=localStorage.getItem("menu-scroll-position"))};function menu_on_scroll(){localStorage.setItem("menu-scroll-position",document.getElementById('menu').scrollLeft)}document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script>
<script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script>
<script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script>
</body>
</html>