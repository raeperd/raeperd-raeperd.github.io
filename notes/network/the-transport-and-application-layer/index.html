<!doctype html><html lang=korean dir=auto>
<head><meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name=robots content="index, follow">
<title>The Transport and Application Layer | raeperd.github.io</title>
<meta name=keywords content="network">
<meta name=description content="INTRO 이제까지 배운 Network Layer 까지의 내용으로는 네트워크 상의 하나의 노드에서 다른 노드로의 통신이 어떤 원리로 이루어지는지 확인할 수 있었다. 그러나 실제로 전달되는 정보를 사용하는 것은 네트워크 기기 안에서 동작하는 프로그램들이며, 특정 프로그램이 요청한 정보는 해당 프로그램에 전달되도록 보장되어야 한다. 크롬 브라우저가 보낸 요청을 워드 프로세스가 받으면 곤란할 것 !
이렇게 프로그램 간의 통신은 어떻게 이루어지는지 확인하지 못했는데, 이제부터 다뤄볼 Transport Layer와 Application Layer에서 이를 확인 할 수 있다. 어떻게 보면 이것이 컴퓨터 네트워크의 최종적인 목적이라 할 수 있다.">
<meta name=author content="raeperd">
<link rel=canonical href=https://raeperd.github.io/notes/network/the-transport-and-application-layer/>
<link href=/assets/css/stylesheet.min.css rel="preload stylesheet" as=style>
<link rel=icon href=https://raeperd.github.io/favicon.ico>
<link rel=icon type=image/png sizes=16x16 href=https://raeperd.github.io/favicon-16x16.png>
<link rel=icon type=image/png sizes=32x32 href=https://raeperd.github.io/favicon-32x32.png>
<link rel=apple-touch-icon href=https://raeperd.github.io/apple-touch-icon.png>
<link rel=mask-icon href=https://raeperd.github.io/safari-pinned-tab.svg>
<meta name=theme-color content="#2e2e33">
<meta name=msapplication-TileColor content="#2e2e33">
<meta name=generator content="Hugo 0.86.1">
<script type=application/javascript>var doNotTrack=!1;doNotTrack||(window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga('create','UA-168674186-1','auto'),ga('send','pageview'))</script>
<script async src=https://www.google-analytics.com/analytics.js></script>
<meta property="og:title" content="The Transport and Application Layer">
<meta property="og:description" content="INTRO 이제까지 배운 Network Layer 까지의 내용으로는 네트워크 상의 하나의 노드에서 다른 노드로의 통신이 어떤 원리로 이루어지는지 확인할 수 있었다. 그러나 실제로 전달되는 정보를 사용하는 것은 네트워크 기기 안에서 동작하는 프로그램들이며, 특정 프로그램이 요청한 정보는 해당 프로그램에 전달되도록 보장되어야 한다. 크롬 브라우저가 보낸 요청을 워드 프로세스가 받으면 곤란할 것 !
이렇게 프로그램 간의 통신은 어떻게 이루어지는지 확인하지 못했는데, 이제부터 다뤄볼 Transport Layer와 Application Layer에서 이를 확인 할 수 있다. 어떻게 보면 이것이 컴퓨터 네트워크의 최종적인 목적이라 할 수 있다.">
<meta property="og:type" content="article">
<meta property="og:url" content="https://raeperd.github.io/notes/network/the-transport-and-application-layer/"><meta property="og:image" content="https://raeperd.github.io/papermod-cover.png"><meta property="article:section" content="notes">
<meta property="article:published_time" content="2020-06-01T00:00:00+00:00">
<meta property="article:modified_time" content="2020-06-01T00:00:00+00:00"><meta property="og:site_name" content="raeperd.github.io">
<meta name=twitter:card content="summary_large_image">
<meta name=twitter:image content="https://raeperd.github.io/papermod-cover.png">
<meta name=twitter:title content="The Transport and Application Layer">
<meta name=twitter:description content="INTRO 이제까지 배운 Network Layer 까지의 내용으로는 네트워크 상의 하나의 노드에서 다른 노드로의 통신이 어떤 원리로 이루어지는지 확인할 수 있었다. 그러나 실제로 전달되는 정보를 사용하는 것은 네트워크 기기 안에서 동작하는 프로그램들이며, 특정 프로그램이 요청한 정보는 해당 프로그램에 전달되도록 보장되어야 한다. 크롬 브라우저가 보낸 요청을 워드 프로세스가 받으면 곤란할 것 !
이렇게 프로그램 간의 통신은 어떻게 이루어지는지 확인하지 못했는데, 이제부터 다뤄볼 Transport Layer와 Application Layer에서 이를 확인 할 수 있다. 어떻게 보면 이것이 컴퓨터 네트워크의 최종적인 목적이라 할 수 있다.">
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Notes","item":"https://raeperd.github.io/notes/"},{"@type":"ListItem","position":2,"name":"The Transport and Application Layer","item":"https://raeperd.github.io/notes/network/the-transport-and-application-layer/"}]}</script>
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"The Transport and Application Layer","name":"The Transport and Application Layer","description":"INTRO 이제까지 배운 Network Layer 까지의 내용으로는 네트워크 상의 하나의 노드에서 다른 노드로의 통신이 어떤 원리로 이루어지는지 확인할 수 있었다. 그러나 실제로 전달되는 정보를 사용하는 것은 네트워크 기기 안에서 동작하는 프로그램들이며, 특정 프로그램이 요청한 정보는 해당 프로그램에 전달되도록 보장되어야 한다. 크롬 브라우저가 보낸 요청을 워드 프로세스가 받으면 곤란할 것 !\n이렇게 프로그램 간의 통신은 어떻게 이루어지는지 확인하지 못했는데, 이제부터 다뤄볼 Transport Layer와 Application Layer에서 이를 확인 할 수 있다. 어떻게 보면 이것이 컴퓨터 네트워크의 최종적인 목적이라 할 수 있다.","keywords":["network"],"articleBody":"INTRO 이제까지 배운 Network Layer 까지의 내용으로는 네트워크 상의 하나의 노드에서 다른 노드로의 통신이 어떤 원리로 이루어지는지 확인할 수 있었다. 그러나 실제로 전달되는 정보를 사용하는 것은 네트워크 기기 안에서 동작하는 프로그램들이며, 특정 프로그램이 요청한 정보는 해당 프로그램에 전달되도록 보장되어야 한다. 크롬 브라우저가 보낸 요청을 워드 프로세스가 받으면 곤란할 것 !\n이렇게 프로그램 간의 통신은 어떻게 이루어지는지 확인하지 못했는데, 이제부터 다뤄볼 Transport Layer와 Application Layer에서 이를 확인 할 수 있다. 어떻게 보면 이것이 컴퓨터 네트워크의 최종적인 목적이라 할 수 있다.\n￼￼￼￼￼￼￼￼￼￼￼ 간단하게 Transport Layer는 네트워크 트래픽이 특정 네트워크 어플리케이션으로 도착할 수 있게 한다. Application Layer는 이 어플리케이션 간에 이해하는 방식으로 통신할 수 있게 한다.\nCONETNS The Transport Layer 앞서 언급한 기능을 위해서 Transport Layer는 multiplex와 demultiplex 를 할 수 있어야 한다.\nmultiplex 는 여러 프로세스가 하나의 ip 주소를 이용해 패킷을 외부로 보낼 수 있게 하는 기능이고, demultiplex 는 반대로, 하나의 입력을 여러 프로세스에 적절하게 분류해서 전달하는 기능이다. 이런 기능을 Port 를 통해 구현할 수 있다.\nPort 네트워크 컴퓨터의 트래픽의 주소를 결정하는 16bit 숫자.\n 이를 통해 하나의 네트워크 기기에서 여러 서비스를 운영할 수 있다. 80번 포트로는 HTTP, 21번 포트로는 FTP, 22 포트로는 SSH 등 ..  Dissection of a TCP Segment TCP Segment Ethernet payload 에 IP Datagram 이 포함되는 것처럼, ID Datagram 의 payload 에 TCP Segment 가 포함된다. 이도 마찬가지로 header와 payload 를 가진다.\nDestination Port / Source Port 이름 그대로의 의미를 가진다. Source Port를 알아야 응답을 하는 쪽에서 어떤 어플리케이션에 응답을 전송해야하는지 알 수 있을 것이다.\nSequence number TCP Segment가 어떤 순서로 전송되었는지를 나타내는 필드\nAcknowledgement number 다음에 올 Sequence를 나타내는 필드\nHeader Length payload가 어디있는지를 가리키는 오프셋 필드\nControl flags  URG (Urgent)  이 flag가 1이면 이 segment가 다른 것 보다 더 중요하다는 것을 의미하며, 자세한 내용은 이후의 Urgent pointer field 에서 확인할 수 있다   ACK (Acknowledged)  acknowledgement number field 가 검사되어야 함을 의미하는 flag   PSH (Push)  buffered data를 보내주기를 요청하는 flag   RST (Reset)  데이터의 송신을 실패했음을 알리는 flag 못알아듣겠으니까 다시한번만 전송해줘   SYN (Synchronize)  처음 TCP 연결을 생성할때 사용되며 sequence number field 를 받는쪽에서 확인하도록 요청하는 flag   FIN (Finish)  다 보냈으니 이제 통신을 끊자고 요청하는 flag    TCP Windows Acknowledgement 필드의 값을 읽기 전에 필요한 sequence number의 범위\nChecksum IP Datagram 의 checksum과 같은 역할\nUrgent pointer field TCP Control flag 와 함께 특정 segment가 다른것 보다 중요하다는 것을 알리는 필드. 최근에는 잘 사용되지는 않는 field 다.\nOptions 복잡한 흐름의 프로토콜에서 사용되는 필드. 최근의 네트워크에서는 잘 사용하지 않는다.\nPading Data payload 가 의도한 offset에서 시작하도록 조절하는 0의 나열.\nTCP Control Flag and 3-way-handshaking 3-way-handshake 두 기기가 서로 같은 Protocol을 통해 통신하고 있고, 서로의 메시지를 이해함을 확인하는 과정.\n 이 후 양쪽 모두 서로에게 메시지를 전달할 수 있으며 이에 대한 응답을 받을 수 있다. 보내는 쪽은 받는 쪽이 ACK 필드와 함께 응답을 보내기 때문에 어떤 메세지를 제대로 전송받았는가 역시 확인할 수 있다. 통신을 끝내기 위해선 FIN flag를 전달하고, 이를 ACK flag로 다시 확인하면서 통신의 종료를 확인한다. 통신을 종료하는 과정은 4-way-handshaking 이라고도 한다.  Socket TCP Connection의 end-point\n 실제로 Socket을 초기화(혹은 인스턴스화?) 하는 프로그램이 필요하다. 어떤 포트로든 TCP packet을 전달할 수 있지만, 받는쪽에서 socket을 열어두었어야만 응답을 받을 수 있을 것이다.  TCK Socket States 이 부분은 번역을 하면 괜히 의미를 해치는 것 같아 원문 그대로 옮긴다.\nLISTEN  A TCP socket is ready and listening for imcoming connections Server-side only  SYN_SENT  A synchronization request has been sent But the connection hasn’t been established yet Client-side only  SYN_RECEIVED  A socket privously in a listener state, has received a synchronization request and sent a SYN_ACK back But hasn’t received SYN_ACK back. Server-side only  ESTABLISHED  This means that the TCP connection is in working order, and both sides are free to send each other data. Both side  FIN_WAIT  This means that a FIN has been sent, but the corresponding ACK from the other end hasn’t been received yet. Both side  CLOSE_WAIT  This means that the connection has been closed at the TCP layer, but that the application that opened the socket hasn’t released its hold on the socket yet. Both side  CLOSED  This means that the connection has been fully terminated, and that no further communication is possible. Both side TCP를 통해 통신을 하기위해서는 양쪽다 규칙을 지켜야하지만 소켓이 정확하게 어떤 상태에 있는가는 TCP의 스펙에서 벗어난 내용이다. 곧 운영체제 마다 정의가 미묘하게 다를 수 있다. 프로그래머가 구현해서 사용할 법한 상태는 크게 OPEN LISTEN CONNECT CLOSE 정도 였던 것으로 기억한다.  Connection-oriented and Connectionless Protocols Establishes a connection, and uses this to ensure that all data has been properly transmitted 이전의 Ethernet frame이나 IP Datagram 의 경우 checksum을 통해 전달받은 데이터가 유효한지 확인은 하지만 만약 전달된 패킷의 checksum이 일치하지 않는 경우 단순히 패기를 할뿐 재전송을 요청하거나 하지는 않는다. 이런 역할을 Transport layer에서 해주게 된다.\nTCP의 프로토콜상 전달받은 Sequence 에 대해서는 ACK field를 통해 전달받았음을 송신자에게 전달함으로써 어떤 정보를 받았고 못받았는지를 알 수 있다. 전달받지 못한 정보에 대해서는 재전송을 하며, 메시지의 순서가 도착된 시간상의 순서와 일치하지 않더라도 받는 쪽에서는 Sequence를 확인하고 올바른 순서로 메세지를 재조합 할 수 있다.\n이런 추가적인 과정은 분명 많은 컴퓨팅 파워를 사용할 수 밖에 없으며 실제 전달하고자 하는 내용보다 더 많은 정도의 트래픽을 사용할 수 밖에 없다. 모든 패킷들이 반드시 전달되어야 하는 경우에는 이런 방식의 프로토콜이 최선일 테지만, 항상 그런 것은 아니다. 일부 패킷의 손실을 감수하고서라도 빠른 전송을 위해서는 UDP 프로토콜이 사용된다.\nConnectionless Protocol - UDP  TCP 와 달리 connection에 의존하지 않고 acknowledgement 와 같은 개념을 지원하지 않는다. 일부 프래임이 유실되어도 큰 무리가 없는 영상 스트리밍의 경우 UDP가 더 효율적인 프로토콜이 된다.  List of TCP and UDP port numbers  Port는 16비트 숫자로 0-65535의 값을 가질 수 있는데 이를 분리해서 사용한다. 0은 네트워크 트래픽에서는 사용되지 않지만, IPC 에서는 사용될 수 있다. 1-1023은 system port 혹은 well-known port 로 주요하게 알려진 네트워크 서비스를 위한 포트들이다. 1024-49151은 registered port로 아주 보편적이지만은 않은 서비스들 위한 포트.  예로 3306은 많은 데이터베이스 어플리케이션들이 사용하는 포트다.   49152-65535는 private port 혹은 ephemeral port라 한다. 외부 네트워크와의 연결을 위해 IANA 에서 사용하지 않는 것을 권고하지만 모든 운영체제가 이를 따르는 것은 아니다.   Service Name and Transport Protocol Port Number Registry  List of TCP and UDP port numbers - Wikipedia    Firewalls A device that blocks traffic that meets certain criteria\n 네트워크 보안에 중요한 역할을 하는 장비다. 여러 layer에서 동작할 수 있지만 보통은 Transport Layer에서 특정 포트의 연결을 차단하는 식으로 많이 사용된다. Firewall 자체가 네트워크 기기일 수도 있지만 현대 운영체제들은 대부분 이를 지원한다. 가정에서 사용되는 네트워크의 경우 보통 router 들이 firewall 의 역할도 같이 하게된다.  The Application Layer #cs/network\nTCP Section도 마찬가지로 data payload를 가지고 있다. Application Layer 의 패킷들은 마찬가지로 다시 TCP Section 의 data payload에 포함되게 된다.\n그런데 이제까지의 Layer들은 대표적인 프로토콜이 몇가지 있었지만, Application Layer에서는 Application 마다 사용하는 프로토콜이 재각각이기 때문에 대표적인 프로토콜이라고 할만한 것이 없다. 대신 Application의 종류에 따라 공통적으로 사용되는 프로토콜은 있다. 대표적인 것이 웹 브라우저와 웹 서버가 사용하는 HTTP 이다. 다양한 모든 브라우저들이 사용하는 프로토콜은 HTTP로 모두 같다.\nThe Application Layer and the OSI Model 이제까지 5 Layer Model 로 네트워크 구조에 대해 공부해 봤는데 일반적으로 많이 쓰이는 모델은 OSI 7 Layer Model 도 많이 사용된다.\nSession Layer  Application Layer 와 Transport Layer 사이의 통신을 가능하게 한다. TCP Segment로 부터 Application Layer의 데이터를 추출하고 이를 Presentation Layer에 전달한다.  Presentation Layer  Session Layer로 부터 전달받은 Application Layer의 데이터가 application이 이해할 수 있도록 하는 역할을 한다.  Session Layer와 Presentation Layer는 운영체제의 일부로 새로운 단계의 캡슐화가 이루어지는 것은 아니다. 그래서 두 Layer를 Application Layer와 같이 이해해도 큰 무리는 없다.\nAll the Layers working in Unison 이제까지의 과정을 한번에 살펴보자. 컴퓨터 1이 브라우저를 통해 웹 서버 컴퓨터 2에 웹 페이지를 요청하는 과정이다.\n 컴퓨터 1은 요청하고 있는 IP 주소가 자신의 네트워크에 없는 것을 확인한다. 다른 네트워크로 요청을 전달하기 위해 자신의 네트워크 안의 라우터를 찾아 내용을 전달한다.  ARP Broadcast 를 통해 라우터의 MAC 주소를 얻는다. Source Port, Destinaion Port 등의 정보로 TCP Segment를 완성한다.  set SYN flag calculate checksum   Source IP, Destination IP 등의 정보로 IP Datagram을 완성한다.  set TTL = 64 (보통 많이 사용하는 값)   Ethernet frame을 완성시키고, 라우터에 전달한다.   라우터 A는 전달받은 패킷을 다시 라우터 B에게 전달한다.  주소 확인 checksum 확인 Ethernet frame을 제거 IP Datagrame 의 TTL을 하나 감소시키고 다시 체크섬을 계산 Ethernet frame을 다시 구성 (라우터 B의 MAC Address를 사용)   라우터 B는 같은 과정을 반복해 컴퓨터 2에게 패킷을 전달한다.  IP Datagram의 IP 주소를 ARP 테이블에서 확인함으로써 MAC 주소를 확인할 수 있다.   컴퓨터2는 전달받은 패킷을 검증하고 이에 맞는 TCP response를 보낸다.  Reference  The Bits and Bytes of Computer Networking\n","wordCount":"1340","inLanguage":"korean","datePublished":"2020-06-01T00:00:00Z","dateModified":"2020-06-01T00:00:00Z","author":{"@type":"Person","name":"raeperd"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://raeperd.github.io/notes/network/the-transport-and-application-layer/"},"publisher":{"@type":"Organization","name":"raeperd.github.io","logo":{"@type":"ImageObject","url":"https://raeperd.github.io/favicon.ico"}}}</script>
</head>
<body id=top>
<script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script>
<noscript>
<style type=text/css>#theme-toggle,.top-link{display:none}</style>
<style>@media(prefers-color-scheme:dark){:root{--theme:#1d1e20;--entry:#2e2e33;--primary:rgba(255, 255, 255, 0.84);--secondary:rgba(255, 255, 255, 0.56);--tertiary:rgba(255, 255, 255, 0.16);--content:rgba(255, 255, 255, 0.74);--hljs-bg:#2e2e33;--code-bg:#37383e;--border:#333}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style>
</noscript>
<header class=header>
<nav class=nav>
<div class=logo>
<a href=https://raeperd.github.io/ accesskey=h title="raeperd.github.io (Alt + H)">raeperd.github.io</a>
<span class=logo-switches>
<button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg>
</button>
</span>
</div>
<ul id=menu onscroll=menu_on_scroll()>
<li>
<a href=https://raeperd.github.io/articles title=Article>
<span>Article</span>
</a>
</li>
<li>
<a href=https://raeperd.github.io/notes title=Note>
<span>Note</span>
</a>
</li>
<li>
<a href=https://raeperd.github.io/search title="Search (Alt + /)" accesskey=/>
<span>Search</span>
</a>
</li>
<li>
<a href=https://raeperd.github.io/archives/ title=Archives>
<span>Archives</span>
</a>
</li></ul>
</nav>
</header>
<main class=main><article class=post-single>
<header class=post-header>
<h1 class=post-title>
The Transport and Application Layer
</h1>
<div class=post-meta>
June 1, 2020&nbsp;·&nbsp;raeperd
</div>
<br>
<ul class=post-tags>
<li><a href=https://raeperd.github.io/tags/network/>network</a></li>
</ul>
</header>
<div class=post-content>
<h1 id=intro>INTRO<a hidden class=anchor aria-hidden=true href=#intro>#</a></h1>
<p>이제까지 배운 Network Layer 까지의 내용으로는 네트워크 상의 하나의 노드에서 다른 노드로의 통신이 어떤 원리로 이루어지는지 확인할 수 있었다. 그러나 실제로 전달되는 정보를 사용하는 것은 네트워크 기기 안에서 동작하는 프로그램들이며, 특정 프로그램이 요청한 정보는 해당 프로그램에 전달되도록 보장되어야 한다. 크롬 브라우저가 보낸 요청을 워드 프로세스가 받으면 곤란할 것 !</p>
<p>이렇게 프로그램 간의 통신은 어떻게 이루어지는지 확인하지 못했는데, 이제부터 다뤄볼 Transport Layer와 Application Layer에서 이를 확인 할 수 있다. 어떻게 보면 이것이 컴퓨터 네트워크의 최종적인 목적이라 할 수 있다.<br>
￼￼￼￼￼￼￼￼￼￼￼
<img loading=lazy src=https://i.ibb.co/tb0tHWM/trasport-layer-in-network-model.png alt>
</p>
<p>간단하게 Transport Layer는 네트워크 트래픽이 특정 네트워크 어플리케이션으로 도착할 수 있게 한다. Application Layer는 이 어플리케이션 간에 이해하는 방식으로 통신할 수 있게 한다.</p>
<h1 id=conetns>CONETNS<a hidden class=anchor aria-hidden=true href=#conetns>#</a></h1>
<h2 id=the-transport-layer>The Transport Layer<a hidden class=anchor aria-hidden=true href=#the-transport-layer>#</a></h2>
<p>앞서 언급한 기능을 위해서 Transport Layer는 multiplex와 demultiplex 를 할 수 있어야 한다.</p>
<p><img loading=lazy src=https://i.ibb.co/pbryNw0/multiplexer-and-demultiplexer.png alt>
</p>
<p>multiplex 는 여러 프로세스가 하나의 ip 주소를 이용해 패킷을 외부로 보낼 수 있게 하는 기능이고, demultiplex 는 반대로, 하나의 입력을 여러 프로세스에 적절하게 분류해서 전달하는 기능이다. 이런 기능을 Port 를 통해 구현할 수 있다.</p>
<h3 id=port>Port<a hidden class=anchor aria-hidden=true href=#port>#</a></h3>
<p>네트워크 컴퓨터의 트래픽의 주소를 결정하는 16bit 숫자.</p>
<ul>
<li>이를 통해 하나의 네트워크 기기에서 여러 서비스를 운영할 수 있다.</li>
<li>80번 포트로는 HTTP, 21번 포트로는 FTP, 22 포트로는 SSH 등 ..</li>
</ul>
<h3 id=dissection-of-a-tcp-segment>Dissection of a TCP Segment<a hidden class=anchor aria-hidden=true href=#dissection-of-a-tcp-segment>#</a></h3>
<h3 id=tcp-segment>TCP Segment<a hidden class=anchor aria-hidden=true href=#tcp-segment>#</a></h3>
<p>Ethernet payload 에 IP Datagram 이 포함되는 것처럼, ID Datagram 의 payload 에 TCP Segment 가 포함된다. 이도 마찬가지로 header와 payload 를 가진다.</p>
<p><img loading=lazy src=https://i.ibb.co/NN5kpyf/tcp-segment.png alt>
</p>
<h4 id=destination-port--source-port>Destination Port / Source Port<a hidden class=anchor aria-hidden=true href=#destination-port--source-port>#</a></h4>
<p>이름 그대로의 의미를 가진다. Source Port를 알아야 응답을 하는 쪽에서 어떤 어플리케이션에 응답을 전송해야하는지 알 수 있을 것이다.</p>
<h4 id=sequence-number>Sequence number<a hidden class=anchor aria-hidden=true href=#sequence-number>#</a></h4>
<p>TCP Segment가 어떤 순서로 전송되었는지를 나타내는 필드</p>
<h4 id=acknowledgement-number>Acknowledgement number<a hidden class=anchor aria-hidden=true href=#acknowledgement-number>#</a></h4>
<p>다음에 올 Sequence를 나타내는 필드</p>
<h4 id=header-length>Header Length<a hidden class=anchor aria-hidden=true href=#header-length>#</a></h4>
<p>payload가 어디있는지를 가리키는 오프셋 필드</p>
<h4 id=control-flags>Control flags<a hidden class=anchor aria-hidden=true href=#control-flags>#</a></h4>
<ul>
<li>URG (Urgent)
<ul>
<li>이 flag가 1이면 이 segment가 다른 것 보다 더 중요하다는 것을 의미하며, 자세한 내용은 이후의 Urgent pointer field 에서 확인할 수 있다</li>
</ul>
</li>
<li>ACK (Acknowledged)
<ul>
<li>acknowledgement number field 가 검사되어야 함을 의미하는 flag</li>
</ul>
</li>
<li>PSH (Push)
<ul>
<li>buffered data를 보내주기를 요청하는 flag</li>
</ul>
</li>
<li>RST (Reset)
<ul>
<li>데이터의 송신을 실패했음을 알리는 flag</li>
<li>못알아듣겠으니까 다시한번만 전송해줘</li>
</ul>
</li>
<li>SYN (Synchronize)
<ul>
<li>처음 TCP 연결을 생성할때 사용되며 sequence number field 를 받는쪽에서 확인하도록 요청하는 flag</li>
</ul>
</li>
<li>FIN (Finish)
<ul>
<li>다 보냈으니 이제 통신을 끊자고 요청하는 flag</li>
</ul>
</li>
</ul>
<h4 id=tcp-windows>TCP Windows<a hidden class=anchor aria-hidden=true href=#tcp-windows>#</a></h4>
<p>Acknowledgement 필드의 값을 읽기 전에 필요한 sequence
number의 범위</p>
<h4 id=checksum>Checksum<a hidden class=anchor aria-hidden=true href=#checksum>#</a></h4>
<p>IP Datagram 의 checksum과 같은 역할</p>
<h4 id=urgent-pointer-field>Urgent pointer field<a hidden class=anchor aria-hidden=true href=#urgent-pointer-field>#</a></h4>
<p>TCP Control flag 와 함께 특정 segment가 다른것 보다 중요하다는 것을 알리는 필드.
최근에는 잘 사용되지는 않는 field 다.</p>
<h4 id=options>Options<a hidden class=anchor aria-hidden=true href=#options>#</a></h4>
<p>복잡한 흐름의 프로토콜에서 사용되는 필드. 최근의 네트워크에서는 잘 사용하지 않는다.</p>
<h4 id=pading>Pading<a hidden class=anchor aria-hidden=true href=#pading>#</a></h4>
<p>Data payload 가 의도한 offset에서 시작하도록 조절하는 0의 나열.</p>
<h3 id=tcp-control-flag-and-3-way-handshaking>TCP Control Flag and 3-way-handshaking<a hidden class=anchor aria-hidden=true href=#tcp-control-flag-and-3-way-handshaking>#</a></h3>
<h3 id=3-way-handshake>3-way-handshake<a hidden class=anchor aria-hidden=true href=#3-way-handshake>#</a></h3>
<p><img loading=lazy src=https://i.ibb.co/SmGvK3T/3-way-hand-shake.png alt>
</p>
<p>두 기기가 서로 같은 Protocol을 통해 통신하고 있고, 서로의 메시지를 이해함을 확인하는 과정.</p>
<ul>
<li>이 후 양쪽 모두 서로에게 메시지를 전달할 수 있으며 이에 대한 응답을 받을 수 있다.</li>
<li>보내는 쪽은 받는 쪽이 ACK 필드와 함께 응답을 보내기 때문에 어떤 메세지를 제대로 전송받았는가 역시 확인할 수 있다.</li>
<li>통신을 끝내기 위해선 FIN flag를 전달하고, 이를 ACK flag로 다시 확인하면서 통신의 종료를 확인한다.</li>
<li>통신을 종료하는 과정은 <strong>4-way-handshaking</strong> 이라고도 한다.</li>
</ul>
<h3 id=socket>Socket<a hidden class=anchor aria-hidden=true href=#socket>#</a></h3>
<p>TCP Connection의 end-point</p>
<ul>
<li>실제로 Socket을 초기화(혹은 인스턴스화?) 하는 프로그램이 필요하다.</li>
<li>어떤 포트로든 TCP packet을 전달할 수 있지만, 받는쪽에서 socket을 열어두었어야만 응답을 받을 수 있을 것이다.</li>
</ul>
<h3 id=tck-socket-states>TCK Socket States<a hidden class=anchor aria-hidden=true href=#tck-socket-states>#</a></h3>
<p>이 부분은 번역을 하면 괜히 의미를 해치는 것 같아 원문 그대로 옮긴다.</p>
<h4 id=listen>LISTEN<a hidden class=anchor aria-hidden=true href=#listen>#</a></h4>
<ul>
<li>A TCP socket is ready and listening for imcoming connections</li>
<li>Server-side only</li>
</ul>
<h4 id=syn_sent>SYN_SENT<a hidden class=anchor aria-hidden=true href=#syn_sent>#</a></h4>
<ul>
<li>A synchronization request has been sent</li>
<li>But the connection hasn’t been established yet</li>
<li>Client-side only</li>
</ul>
<h4 id=syn_received>SYN_RECEIVED<a hidden class=anchor aria-hidden=true href=#syn_received>#</a></h4>
<ul>
<li>A socket privously in a listener state, has received a synchronization request and sent a <strong>SYN_ACK</strong> back</li>
<li>But hasn’t received SYN_ACK back.</li>
<li>Server-side only</li>
</ul>
<h4 id=established>ESTABLISHED<a hidden class=anchor aria-hidden=true href=#established>#</a></h4>
<ul>
<li>This means that the TCP connection is in working order, and both sides are free to send each other data.</li>
<li>Both side</li>
</ul>
<h4 id=fin_wait>FIN_WAIT<a hidden class=anchor aria-hidden=true href=#fin_wait>#</a></h4>
<ul>
<li>This means that a FIN has been sent, but the corresponding ACK from the other end hasn’t been received yet.</li>
<li>Both side</li>
</ul>
<h4 id=close_wait>CLOSE_WAIT<a hidden class=anchor aria-hidden=true href=#close_wait>#</a></h4>
<ul>
<li>This means that the connection has been closed at the TCP layer, but that the application that opened
the socket hasn’t released its hold on the socket yet.</li>
<li>Both side</li>
</ul>
<h4 id=closed>CLOSED<a hidden class=anchor aria-hidden=true href=#closed>#</a></h4>
<ul>
<li>This means that the connection has been fully terminated, and that no further communication is possible.</li>
<li>Both side
TCP를 통해 통신을 하기위해서는 양쪽다 규칙을 지켜야하지만 소켓이 정확하게 어떤 상태에 있는가는 TCP의 스펙에서 벗어난 내용이다. 곧 운영체제 마다 정의가 미묘하게 다를 수 있다. 프로그래머가 구현해서 사용할 법한 상태는 크게 OPEN LISTEN CONNECT CLOSE 정도 였던 것으로 기억한다.</li>
</ul>
<h3 id=connection-oriented-and-connectionless-protocols>Connection-oriented and Connectionless Protocols<a hidden class=anchor aria-hidden=true href=#connection-oriented-and-connectionless-protocols>#</a></h3>
<p>Establishes a connection, and uses this to ensure that all data has been properly transmitted
이전의 Ethernet frame이나 IP Datagram 의 경우 checksum을 통해 전달받은 데이터가 유효한지 확인은 하지만 만약 전달된 패킷의 checksum이 일치하지 않는 경우 단순히 패기를 할뿐 재전송을 요청하거나 하지는 않는다. 이런 역할을 Transport layer에서 해주게 된다.</p>
<p>TCP의 프로토콜상 전달받은 Sequence 에 대해서는 ACK field를 통해 전달받았음을 송신자에게 전달함으로써 어떤 정보를 받았고 못받았는지를 알 수 있다. 전달받지 못한 정보에 대해서는 재전송을 하며, 메시지의 순서가 도착된 시간상의 순서와 일치하지 않더라도 받는 쪽에서는 Sequence를 확인하고 올바른 순서로 메세지를 재조합 할 수 있다.</p>
<p>이런 추가적인 과정은 분명 많은 컴퓨팅 파워를 사용할 수 밖에 없으며 실제 전달하고자 하는 내용보다 더 많은 정도의 트래픽을 사용할 수 밖에 없다. 모든 패킷들이 반드시 전달되어야 하는 경우에는 이런 방식의 프로토콜이 최선일 테지만, 항상 그런 것은 아니다. 일부 패킷의 손실을 감수하고서라도 빠른 전송을 위해서는 UDP 프로토콜이 사용된다.</p>
<h3 id=connectionless-protocol---udp>Connectionless Protocol - UDP<a hidden class=anchor aria-hidden=true href=#connectionless-protocol---udp>#</a></h3>
<ul>
<li>TCP 와 달리 connection에 의존하지 않고 acknowledgement 와 같은 개념을 지원하지 않는다.</li>
<li>일부 프래임이 유실되어도 큰 무리가 없는 영상 스트리밍의 경우 UDP가 더 효율적인 프로토콜이 된다.</li>
</ul>
<h3 id=list-of-tcp-and-udp-port-numbers>List of TCP and UDP port numbers<a hidden class=anchor aria-hidden=true href=#list-of-tcp-and-udp-port-numbers>#</a></h3>
<ul>
<li>Port는 16비트 숫자로 0-65535의 값을 가질 수 있는데 이를 분리해서 사용한다.</li>
<li>0은 네트워크 트래픽에서는 사용되지 않지만, IPC 에서는 사용될 수 있다.</li>
<li>1-1023은 <strong>system port</strong> 혹은 <strong>well-known port</strong> 로 주요하게 알려진 네트워크 서비스를 위한 포트들이다.</li>
<li>1024-49151은 registered port로 아주 보편적이지만은 않은 서비스들 위한 포트.
<ul>
<li>예로 3306은 많은 데이터베이스 어플리케이션들이 사용하는 포트다.</li>
</ul>
</li>
<li>49152-65535는 private port 혹은 ephemeral port라 한다. 외부 네트워크와의 연결을 위해
<a href=https://www.iana.org/ target=_blank>IANA</a> 에서 사용하지 않는 것을 권고하지만 모든 운영체제가 이를 따르는 것은 아니다.
<ul>
<li>
<a href=https://www.iana.org/assignments/service-names-port-numbers/service-names-port-numbers.xhtml target=_blank>Service Name and Transport Protocol Port Number Registry</a></li>
<li>
<a href=https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers target=_blank>List of TCP and UDP port numbers - Wikipedia</a></li>
</ul>
</li>
</ul>
<h3 id=firewalls>Firewalls<a hidden class=anchor aria-hidden=true href=#firewalls>#</a></h3>
<p>A device that blocks traffic that meets certain criteria</p>
<ul>
<li>네트워크 보안에 중요한 역할을 하는 장비다.</li>
<li>여러 layer에서 동작할 수 있지만 보통은 Transport Layer에서 특정 포트의 연결을 차단하는 식으로 많이 사용된다.</li>
<li>Firewall 자체가 네트워크 기기일 수도 있지만 현대 운영체제들은 대부분 이를 지원한다.</li>
<li>가정에서 사용되는 네트워크의 경우 보통 router 들이 firewall 의 역할도 같이 하게된다.</li>
</ul>
<p><img loading=lazy src=https://i.ibb.co/ZdHHYMR/firewall.png alt>
</p>
<h1 id=the-application-layer>The Application Layer<a hidden class=anchor aria-hidden=true href=#the-application-layer>#</a></h1>
<p>#cs/network</p>
<p>TCP Section도 마찬가지로 data payload를 가지고 있다. Application Layer 의 패킷들은 마찬가지로 다시 TCP Section 의 data payload에 포함되게 된다.</p>
<p><img loading=lazy src=https://i.ibb.co/DkkFCbp/application-layer-and-osi-model.png alt>
</p>
<p>그런데 이제까지의 Layer들은 대표적인 프로토콜이 몇가지 있었지만, Application Layer에서는 Application 마다 사용하는 프로토콜이 재각각이기 때문에 대표적인 프로토콜이라고 할만한 것이 없다. 대신 Application의 종류에 따라 공통적으로 사용되는 프로토콜은 있다. 대표적인 것이 웹 브라우저와 웹 서버가 사용하는 HTTP 이다. 다양한 모든 브라우저들이 사용하는 프로토콜은 HTTP로 모두 같다.</p>
<h3 id=the-application-layer-and-the-osi-model>The Application Layer and the OSI Model<a hidden class=anchor aria-hidden=true href=#the-application-layer-and-the-osi-model>#</a></h3>
<p><img loading=lazy src=https://i.ibb.co/DkkFCbp/application-layer-and-osi-model.png alt>
</p>
<p>이제까지 5 Layer Model 로 네트워크 구조에 대해 공부해 봤는데 일반적으로 많이 쓰이는 모델은 OSI 7 Layer Model 도 많이 사용된다.</p>
<h3 id=session-layer>Session Layer<a hidden class=anchor aria-hidden=true href=#session-layer>#</a></h3>
<ul>
<li>Application Layer 와 Transport Layer 사이의 통신을 가능하게 한다.</li>
<li>TCP Segment로 부터 Application Layer의 데이터를 추출하고 이를 Presentation Layer에 전달한다.</li>
</ul>
<h3 id=presentation-layer>Presentation Layer<a hidden class=anchor aria-hidden=true href=#presentation-layer>#</a></h3>
<ul>
<li>Session Layer로 부터 전달받은 Application Layer의 데이터가 application이 이해할 수 있도록 하는 역할을 한다.</li>
</ul>
<p>Session Layer와 Presentation Layer는 운영체제의 일부로 새로운 단계의 캡슐화가 이루어지는 것은 아니다. 그래서 두 Layer를 Application Layer와 같이 이해해도 큰 무리는 없다.</p>
<h3 id=all-the-layers-working-in-unison>All the Layers working in Unison<a hidden class=anchor aria-hidden=true href=#all-the-layers-working-in-unison>#</a></h3>
<p><img loading=lazy src=https://i.ibb.co/LvY8JLv/all-the-layers-working-in-union.png alt>
</p>
<p>이제까지의 과정을 한번에 살펴보자. 컴퓨터 1이 브라우저를 통해 웹 서버 컴퓨터 2에 웹 페이지를 요청하는 과정이다.</p>
<ol>
<li>컴퓨터 1은 요청하고 있는 IP 주소가 자신의 네트워크에 없는 것을 확인한다.</li>
<li>다른 네트워크로 요청을 전달하기 위해 자신의 네트워크 안의 라우터를 찾아 내용을 전달한다.
<ul>
<li>ARP Broadcast 를 통해 라우터의 MAC 주소를 얻는다.</li>
<li>Source Port, Destinaion Port 등의 정보로 TCP Segment를 완성한다.
<ul>
<li>set SYN flag</li>
<li>calculate checksum</li>
</ul>
</li>
<li>Source IP, Destination IP 등의 정보로 IP Datagram을 완성한다.
<ul>
<li>set TTL = 64 (보통 많이 사용하는 값)</li>
</ul>
</li>
<li>Ethernet frame을 완성시키고, 라우터에 전달한다.</li>
</ul>
</li>
<li>라우터 A는 전달받은 패킷을 다시 라우터 B에게 전달한다.
<ul>
<li>주소 확인</li>
<li>checksum 확인</li>
<li>Ethernet frame을 제거</li>
<li>IP Datagrame 의 TTL을 하나 감소시키고 다시 체크섬을 계산</li>
<li>Ethernet frame을 다시 구성 (라우터 B의 MAC Address를 사용)</li>
</ul>
</li>
<li>라우터 B는 같은 과정을 반복해 컴퓨터 2에게 패킷을 전달한다.
<ul>
<li>IP Datagram의 IP 주소를 ARP 테이블에서 확인함으로써 MAC 주소를 확인할 수 있다.</li>
</ul>
</li>
<li>컴퓨터2는 전달받은 패킷을 검증하고 이에 맞는 TCP response를 보낸다.</li>
</ol>
<h1 id=reference>Reference<a hidden class=anchor aria-hidden=true href=#reference>#</a></h1>
<p>
<a href=https://www.coursera.org/learn/computer-networking/home/welcome target=_blank>The Bits and Bytes of Computer Networking</a></p>
</div>
<footer class=post-footer>
<div class=share-buttons>
<a target=_blank rel="noopener noreferrer" aria-label="share The Transport and Application Layer on twitter" href="https://twitter.com/intent/tweet/?text=The%20Transport%20and%20Application%20Layer&url=https%3a%2f%2fraeperd.github.io%2fnotes%2fnetwork%2fthe-transport-and-application-layer%2f&hashtags=network"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share The Transport and Application Layer on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fraeperd.github.io%2fnotes%2fnetwork%2fthe-transport-and-application-layer%2f&title=The%20Transport%20and%20Application%20Layer&summary=The%20Transport%20and%20Application%20Layer&source=https%3a%2f%2fraeperd.github.io%2fnotes%2fnetwork%2fthe-transport-and-application-layer%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share The Transport and Application Layer on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fraeperd.github.io%2fnotes%2fnetwork%2fthe-transport-and-application-layer%2f&title=The%20Transport%20and%20Application%20Layer"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share The Transport and Application Layer on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fraeperd.github.io%2fnotes%2fnetwork%2fthe-transport-and-application-layer%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share The Transport and Application Layer on whatsapp" href="https://api.whatsapp.com/send?text=The%20Transport%20and%20Application%20Layer%20-%20https%3a%2f%2fraeperd.github.io%2fnotes%2fnetwork%2fthe-transport-and-application-layer%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share The Transport and Application Layer on telegram" href="https://telegram.me/share/url?text=The%20Transport%20and%20Application%20Layer&url=https%3a%2f%2fraeperd.github.io%2fnotes%2fnetwork%2fthe-transport-and-application-layer%2f"><svg viewBox="2 2 28 28"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg>
</a>
</div>
</footer><div id=disqus_thread></div>
<script>(function(){var a=document,b=a.createElement('script');b.src='https://raeperd-github-io.disqus.com/embed.js',b.setAttribute('data-timestamp',+new Date),(a.head||a.body).appendChild(b)})()</script>
<noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript>
</article>
</main><footer class=footer>
<span>&copy; 2021 <a href=https://raeperd.github.io/>raeperd.github.io</a></span>
<span>&#183;</span>
<span>Powered by <a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a></span>
<span>&#183;</span>
<span>Theme <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span>
</footer>
<a href=#top aria-label="go to top" title="Go to Top (Alt + G)">
<button class=top-link id=top-link type=button accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</button>
</a>
<script defer src=/assets/js/highlight.min.js onload=hljs.initHighlightingOnLoad()></script>
<script>window.onload=function(){localStorage.getItem("menu-scroll-position")&&(document.getElementById('menu').scrollLeft=localStorage.getItem("menu-scroll-position"))};function menu_on_scroll(){localStorage.setItem("menu-scroll-position",document.getElementById('menu').scrollLeft)}document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script>
<script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script>
<script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script>
</body>
</html>