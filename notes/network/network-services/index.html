<!doctype html><html lang=korean dir=auto>
<head><meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name=robots content="index, follow">
<title>Network Services | raeperd.github.io</title>
<meta name=keywords content="network">
<meta name=description content="INTRO 기초가 참 힘들다. 뭐든지 기초가 참 힘든거 같다. 퇴근하고 공부하는게 참 힘든일이긴 한데 그냥 코딩하는거면 어떻게든 재미를 찾을 수 있을 것 같은데 기초 공부라는게 되게 지루하다. 농구선수가 운동장 달리고 푸쉬업 하는 것처럼 기초는 중요하지만 귀찮고 재미없고 따분하기만 하다. 그래도 해야지 뭐 하면서 또 하게 된다. 잘 좀 하자.
CONETNS Name Resolution Why do we need DNS? 우리가 접속해야하는 사이트마다 IP 주소를 기억해야 한다고 생각하면 참 귀찮을 것이다. 사람들은 숫자를 기억하는 것보다 단어를 더 잘 기억한다.">
<meta name=author content="raeperd">
<link rel=canonical href=https://raeperd.github.io/notes/network/network-services/>
<link href=/assets/css/stylesheet.min.css rel="preload stylesheet" as=style>
<link rel=icon href=https://raeperd.github.io/favicon.ico>
<link rel=icon type=image/png sizes=16x16 href=https://raeperd.github.io/favicon-16x16.png>
<link rel=icon type=image/png sizes=32x32 href=https://raeperd.github.io/favicon-32x32.png>
<link rel=apple-touch-icon href=https://raeperd.github.io/apple-touch-icon.png>
<link rel=mask-icon href=https://raeperd.github.io/safari-pinned-tab.svg>
<meta name=theme-color content="#2e2e33">
<meta name=msapplication-TileColor content="#2e2e33">
<meta name=generator content="Hugo 0.86.1">
<script type=application/javascript>var doNotTrack=!1;doNotTrack||(window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga('create','UA-168674186-1','auto'),ga('send','pageview'))</script>
<script async src=https://www.google-analytics.com/analytics.js></script>
<meta property="og:title" content="Network Services">
<meta property="og:description" content="INTRO 기초가 참 힘들다. 뭐든지 기초가 참 힘든거 같다. 퇴근하고 공부하는게 참 힘든일이긴 한데 그냥 코딩하는거면 어떻게든 재미를 찾을 수 있을 것 같은데 기초 공부라는게 되게 지루하다. 농구선수가 운동장 달리고 푸쉬업 하는 것처럼 기초는 중요하지만 귀찮고 재미없고 따분하기만 하다. 그래도 해야지 뭐 하면서 또 하게 된다. 잘 좀 하자.
CONETNS Name Resolution Why do we need DNS? 우리가 접속해야하는 사이트마다 IP 주소를 기억해야 한다고 생각하면 참 귀찮을 것이다. 사람들은 숫자를 기억하는 것보다 단어를 더 잘 기억한다.">
<meta property="og:type" content="article">
<meta property="og:url" content="https://raeperd.github.io/notes/network/network-services/"><meta property="og:image" content="https://raeperd.github.io/papermod-cover.png"><meta property="article:section" content="notes">
<meta property="article:published_time" content="2020-06-21T00:00:00+00:00">
<meta property="article:modified_time" content="2020-06-21T00:00:00+00:00"><meta property="og:site_name" content="raeperd.github.io">
<meta name=twitter:card content="summary_large_image">
<meta name=twitter:image content="https://raeperd.github.io/papermod-cover.png">
<meta name=twitter:title content="Network Services">
<meta name=twitter:description content="INTRO 기초가 참 힘들다. 뭐든지 기초가 참 힘든거 같다. 퇴근하고 공부하는게 참 힘든일이긴 한데 그냥 코딩하는거면 어떻게든 재미를 찾을 수 있을 것 같은데 기초 공부라는게 되게 지루하다. 농구선수가 운동장 달리고 푸쉬업 하는 것처럼 기초는 중요하지만 귀찮고 재미없고 따분하기만 하다. 그래도 해야지 뭐 하면서 또 하게 된다. 잘 좀 하자.
CONETNS Name Resolution Why do we need DNS? 우리가 접속해야하는 사이트마다 IP 주소를 기억해야 한다고 생각하면 참 귀찮을 것이다. 사람들은 숫자를 기억하는 것보다 단어를 더 잘 기억한다.">
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Notes","item":"https://raeperd.github.io/notes/"},{"@type":"ListItem","position":2,"name":"Network Services","item":"https://raeperd.github.io/notes/network/network-services/"}]}</script>
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Network Services","name":"Network Services","description":"INTRO 기초가 참 힘들다. 뭐든지 기초가 참 힘든거 같다. 퇴근하고 공부하는게 참 힘든일이긴 한데 그냥 코딩하는거면 어떻게든 재미를 찾을 수 있을 것 같은데 기초 공부라는게 되게 지루하다. 농구선수가 운동장 달리고 푸쉬업 하는 것처럼 기초는 중요하지만 귀찮고 재미없고 따분하기만 하다. 그래도 해야지 뭐 하면서 또 하게 된다. 잘 좀 하자.\nCONETNS Name Resolution Why do we need DNS? 우리가 접속해야하는 사이트마다 IP 주소를 기억해야 한다고 생각하면 참 귀찮을 것이다. 사람들은 숫자를 기억하는 것보다 단어를 더 잘 기억한다.","keywords":["network"],"articleBody":"INTRO 기초가 참 힘들다. 뭐든지 기초가 참 힘든거 같다. 퇴근하고 공부하는게 참 힘든일이긴 한데 그냥 코딩하는거면 어떻게든 재미를 찾을 수 있을 것 같은데 기초 공부라는게 되게 지루하다. 농구선수가 운동장 달리고 푸쉬업 하는 것처럼 기초는 중요하지만 귀찮고 재미없고 따분하기만 하다. 그래도 해야지 뭐 하면서 또 하게 된다. 잘 좀 하자.\nCONETNS Name Resolution Why do we need DNS? 우리가 접속해야하는 사이트마다 IP 주소를 기억해야 한다고 생각하면 참 귀찮을 것이다. 사람들은 숫자를 기억하는 것보다 단어를 더 잘 기억한다. 그래서 IP 주소에 단어로 된 이름을 부여하는 것이 좋을 것.\nDomain Name DNS(Domain name system)에 의해 resolve 될 수 있는 용어.\n모든 접속을 Domain Name으로 하도록 한다면, IP 주소가 바뀌더라도 사용자는 같은 방법으로 접근할 수 있다. 관리자는 DNS 로 해당하는 IP 주소만을 변경해주면 된다.\n물리적으로 가까운 곳이면 당연히 통신은 빠를 것이다. 글로벌한 서비스를 제공하려면 하나의 서버가 아니라 분산되게 서버를 운영하는 것이 좋을 것. DNS는 다른 지역에서 접근하는 서비스들을 해당 지역에 맞는, 효율적인 IP 주소로 변경해줄 수 있다.\nThe Many Steps of Name Resolution Name resolution 도메인 이름을 IP 주소로 변경하는 과정\nDNS 없이 네트워크는 동작하지만 컴퓨터를 사용하는 사람은 불편할 것이다. 설정해주는 것이 좋다.\n총 5가지 종류의 DNS Server가 있다.\n Caching name servers Recursive name servers Root name servers TLD name servers Authoritative name servers  TTL (Time to live) 초 단위로 도메인 네임을 얼마나 오래 저장할지를 나타낸다. 도메인 네임의 소유자가 설정할 수 있다.\n 이전에는 트래픽을 줄이기 위해 하루 정도의 긴 값을 가졌다. 최근에는 몇분 혹은 몇시간 정도로 많이 설정되지만, 여전히 긴 경우도 발견할 수 있다.  Anycast  위치나 네트워크 상태등을 바탕으로 트래픽을 다른 목적지로 라우팅하는 기술이다. 이를 이용해 하나의 IP로 전달하는 패킷이 실제로는 다른 도착지로 전달될 수 있다.  TLD (Top-level domain)  도메인 이름의 마지막 부분 .com 과 같은 부분    Root Server 로부터 TLD name server 의 주소를 전달 받는다. TLD Name Server 로부터 authoritative name server의 주소를 전달 받는다. Query   Root Server와 TLD Name Server를 운영하는 곳은 적지만 Anycast와 같은 기술을 통해 물리적으로는 다른 주소로 트래픽이 redirect 된다. 이렇게 도메인 네임을 여러 단계로 얻어와야만 악의적인 공격자로 부터 안전하게 DNS 를 사용할 수 있다.  DNS and UDP DNS 는 TCP 대신 UDP 를 많이 쓴다. Name resolution에 드는 패킷의 차이가 많다. Name resolution의 한번의 요청과 응답의 경우, TCP connection 한번에 아래와 같은 송수신이 필요하다.\n 3 way handshake 요청 요청을 받았다는 ack 응답 응답을 받았다는 ack 4 way-hand shake = 3 + 2 + 2 + 4 = 11  반면 UDP 의 경우 주고 받는 패킷 하나씩 2번, 총 8개의 패킷 만으로 전체 Name resolution을 처리할 수 있다. 그래서 보통 DNS는 UDP를 많이 사용한다.\nName Resolution in Practice Resource Record Types DNS가 정보를 기록하는 방식은 여러가지 방법이 있다.\nA record 도메인 네임은 특정한 IPv4 주소를 가리키는데 사용된다.\n 보통은 하나의 도메인 네임은 하나의 A record를 가진다. 하나의 도메인 네임이 여러개의 A record를 가질 수 있는데, 이를 통해 DNS Round robin이 가능하다.  DNS Round Robin  여러 IP를 반복하면서 DNS Name Resolution의 트래픽을 관리하는 방법. 하나의 DNS, microsoft.com에 IP 주소 4개의 A record를 가지게 했다고 가정해보자. 각각의 주소는 10.0.0.1 ~ 10.0.0.4이다. Name Resolution 요청에 DNS Resolver는 모든 IP 주소를 반환한다. 응답을 받은 컴퓨터는 자신이 전달받은 IP 주소 중 첫번째 주소(10.0.0.1)를 이용해야 한다는 것을 알고 있다. 그러나 첫번째 주소가 응답하지 않는 경우에 대비해서 주소 4개를 모두 가지고 있는다. 두번째로 microsoft.com 주소를 요청하는 컴퓨터 또한 마찬가지로 4가지 주소를 모두 전달받지만, 이번에 전달받은 주소의 첫번째 값은 10.0.0.1이 아닌 10.0.0.2 이다. 이 컴퓨터는 첫 연걸을 10.0.0.2 에 시도하게 되며, 이런 방식은 모든 DNS resolution 시도에서 동작하며, 트래픽을 분산시킨다.  Quad A record 도메인 네임을 특정한 IPv6 주소를 가리키는데 사용한다.\nCNAME record (Canonical name record)  하나의 도메인에 다른 이름을 부여하는 방식 하나의 도메인을 다른 도메인으로 redirect 하는데 사용된다. 하나의 IP 주소가 여러 도메인을 가지도록 설정됬다고 해보자. 만약 IP 주소가 변경된다면 각각의 도메인의 A record를 변경하는 작업을 해야한다. CNAME record를 이용해 대표 도메인을 설정하고, 다른 도메인들은 CNAME record를 통해 대표 도메인을 가리키도록 설정한다면 추후에 IP 주소가 변경되더라도 하나의 A record만 변경하는 것으로 수정을 최소화 할 수 있다.  MX record (Mail exchange)  e-mail을 올바른 서버로 전달하기 위해 사용되는 레코드 많은 회사들이 웹과 메일 서버를 다른 기기, 다른 IP 주소에서 서비스하게 된다. MX record 는 웹 트래픽은 웹서버, 메일 트래픽은 메일 서버에게 전달될 수 있도록 한다.  SRV record (Service record)  MX record와 유사하게 여러가지 서비스들의 위치들을 알아내는데 사용된다. MX record와 동일하게 동작하는 대신, SRV record는 mail 서비스이외의 다른 종류의 서비스들에게 트래픽을 전달한다.  TXT record (Text record)  도메인 네임에 대해 사람이 읽을 수 있는 노트를 위한 record. 현대의 네트워크에서는 다른 컴퓨터가 처리할 수 있는 추가적인 정보를 많이 포함하기도 한다. 형식의 제한이 없는 record라 이를 이용해서 DNS가 원래 의도하지 않았던 추가적인 정보까지 전달하는 것이 가능하다. 신뢰된 다른 네트워크 서비스와 관련된 설정들을 공유하는데 사용되기도 한다. 예를 들면 이메일 서비스와 관련된 설정들을 공유하기도 한다고 하는데 눈으로 보고 코딩을 해보기전까지는 어떤 역할을 하는지 정확하게 감을 잡기는 힘들 것 같다.  Anatomy of a Domain Name 모든 도메인은 세가지로 나뉜다. 1. subdomain (www) a.k.a hostname 2. domain (.google) - TLD name server - authoritive name server 사이의 전환에 사용 3. top-level domain (.com) - ICANN 이라는 곳에서 관리한다.\n 이 세가지를 모두 갖추면 FQDN(Fully qualified domain name) 이라불림 subdomain을 여러개 가지는것도 가능하다. 물론 글자수 등에 제한은 있다.  subdomain.domain.top-level-domain (ex .help.acme.com)\nDNS Zones DNS Zone은 Domain namesapce의 고유한 부분으로 DNS Zone을 유지 및 관리를 하는 개인, 조직, 회사에 위임된 도메인 네임 스페이스다.\n  통상 DNS 서버 하나가 책임이나 권한을 가지는 영역을 말한다\n  여러 레벨의 도메인 네임을 더 다루기 쉽게 해주는 것이 목적\n  zone 은 겹치지 않는다.   3개의 zone 과 하나의 대표 zone 으로 분리하면, 하나의 zone과 600개의 A record를 쓰는 것보다는 낫다.\n largecompany.com la.largecompany.com pa.largecompany.com sh.largecompany.com    Root name server, Root zone 각각의 TLD 서버들은 특정 TLD의 zone들을 커버한다.\nauthoritatve name server 들은 더 세분화된 zone들을 커버한다.\nZone files 특정 zone에 대한 모든 resource record를 저장하고 있는 configuration file\nSOA record (Start of authority) zone과 해당 zone을 관리하는 name server의 이름이 저장되어 있는 record\nZone file 이 가지고 있다.\nNS record 이 zone을 책임지는 또 다른 name server 들을 가리키는 레코드\nsingle point of failure 를 피하기위해 하나의 zone 을 여러 물리적 서버에서 관리할 수 있다.\nReverse lookup zone files IP에 해당하는 FQDN(Full Qualified Domain Name)을 가지고 있는 파일\nPointer resource record Resolves ip to a name.\nDynamic Host Configuration Protocol Overview of DHCP  IP Subnet mask Gateway Name server  네트워크 설정을 할떄, 반드시 설정해야하는 것들은 위 4가지 인데 여러 기기에 모두 설정하려면 귀찮은 일이 될 것 이다. 마지막 3개는 같은 네트워크 안이라면 보통 같을 것이다. IP는 달라져야 한다.\nDHCP는 이런 귀찮은 일을 해주기 위해 필요하다.\nDHCP (Dynamic Host Configuration Protocol) 호스트에서 네트워크 설정들을 자동으로 하게 해주기 위한 application layer protocol\n 기기가 DHCP 서버에 네트웤 설정을 요청하면 네트웤 설정들을 한번에 받아올 수 있다. 관리자의 일을 줄여줄 뿐만 아니라 어떤 IP를 어떤 기기에 할당하는지 정하는 것도 설정할 수 있다. DHCP가 네트워크 관리자가 해야하는 설정들을 자동으로 해주는 것 뿐만 아니라 IP를 어떻게 할당하는가에 대한 문제도 해결해 준다.  모든 기기의 모든 IP 들이 외부 네트워크로부터 공개될 필요는 없다. 서버 장비나 게이트웨이 라우터의 IP는 static 하고 public한 형태로 관리되어야 한다.\n예를 들면 같은 네트워크의 장비들은 게이트웨이의 주소를 항상 알고 있을 필요가 있다.\n만약 로컬 DNS 서버가 동작하지 않는다고 해보자. 네트워크 관리자는 새로운 DNS 주소를 통해 문제를 해결 할 수 있을 것이다. DNS 서버를 static 하게 설정하지 않는다면, DNS 서버가 동작하지 않을때 문제점을 확인하는 것이 어려울 것이다.\n그러나 다른 클라이언트 기기들은 올바른 네트워크 안에서 올바른 IP 주소를 가지고 있는가만 중요한 문제가 된다. 정확히 어떤 IP 주소를 가지느냐는 별로 중요하지 않다. DHCP를 사용하면 이러한 클라이언트 기기들을 위한 IP 주소들을 따로 할당해 둘 수 있다. 이런 방식으로 클라이언트 기기들은 필요할 때마다 IP 주소를 할당받을 수 있다. 그러면 모든 네트워크 장비들과 해당하는 IP 의 목록들을 관리할 필요가 없다.\nDHCP dynamic allocation\nA range of IP addresses is set aside for client devices and one of these IPs is issued to these devices when they request one.\nDHCP automatic allocation\nAutomatic allocation is very similar to dynamic allocation, in that a range of IP addresses is set aside for assignment purposes. The main difference here is that the DHCP server is asked to keep track of which IPs it’s assigned to certain devices in the past. Using this information, the DHCP server will assign the same IP to the same machine each time, if possible.\n(해석하는 것보다 원본이 더 의미를 잘 전달하는 것 같다)\nDHCP fixed allocation\nFixed allocation requires a manually specified list of MAC address and the corresponding IPs.\n 보안상의 목적으로 이렇게 쓰일 수 있다.  NTP 서버를 할당하는 등에도 사용할 수 있다.\nDHCP in Action DHCP는 application layer 프로토콜이지만 DHCP의 포인트는 이 자체로 네트워크 레이어의 특징들을 결정하는데 있다. 아래와 같은 과정으로 설정을 공유할 수 있다.\nDHCPDISCOVER 네트워크 설정을 얻기 위해 클라이언트의 시도\n최초의 클라이언트는 항상 68포트로부터 67포트에게 브로드캐스트로 DHCPDISCOVER 메시지를 보낸다. Transport layer의 프로토콜은 UDP를 사용한다. 이런 메시지는 네트웤의 모든 노드에 전달되며 만약 DHCP 서버가 있다면 서버는 DHCPOFFER 메세지를 보낸다.\nDHCPOFFER 서버는 DHCPOFFER 메세지를 통해 클라이언트에게 IP 주소를 전달하는데 이 메세지의 패킷은 브로드캐스트로 전달된다. 최초의 DHCPDISCOVER 를 전송한 클라이언트는 DHCPOFFER 메세지에 포함되어있는, 요청을 보낸 클라이언트의 MAC 주소로부터 해당 DHCPOFFER 메시지가 자신에게 보내진 것임을 알 수 있다.\n이떄 서버가 할당하는 IP 주소는 앞에서 알아본 allocation 설정이 어떻게 되어있느냐에 따라 할당된다.\n클라이언트는 이런 DHCPOFFER 를 거절할 수 있는데, 여러 DHCP 서버가 네트워크에 있는 환경에서 특정 IP 주소를 거절하는 식으로 구현되기도 한다. 그러나 드문 케이스다. 클라이언트는 DHCPOFFER 메시지의 응답으로 DHCPREQUEST 메시지를 보낸다.\nDHCPREQUEST 이 메시지는 보통 앞선 DHCPOFFER를 통해 할당된 IP 주소를 사용하겠다는 동의 의사를 전달하는데, 아직 IP의 할당이 완전하게 이루어진 것은 아니기 때문에 0.0.0.0:68 의 주소로, 브로드캐스트로 전달한다. 이후 서버는 DHCPACK 메시지로 응답한다.\nDHCPACK DHCPOFFER와 마찬가지로 메시지에 포함되어 있는 MAC 주소를 통해 클라이언트는 본인에게 보내는 메시지임을 확인할 수 있다. 이제 클라이언트는 이제 DHCP Server를 통해 네트워크 설정을 할 수 있다.\n이 단계에서 DHCP 클라이언트 역할을하는 컴퓨터에는 연결된 네트워크에서 본격적으로 작동하는 데 필요한 모든 정보가 있어야 한다. 이런 정보를 DHCP lease 라고 한다.\nDHCP lease 는 expire time 을 가지고 있는데, 클라이언트가 가지고있는 lease가 파기되면 DHCP Discovery 부터 시작해서 다시 DHCP의 모든 과정을 반복해야한다.\n클라이언트 또한 DHCP Server에게 lease 를 생성할 수 있는데, 네트워크로부터 disconnect를 할때 사용한다. 이 정보를 통해 DHCP server는 할당되었던 IP를 다시 재할당 가능한 IP pool에 추가할 수 있다.\nNetwork Address Translation Baiscs of NAT 게이트웨이(일반적으로 라우터 또는 방화벽)가 발신 IP 데이터 그램의 소스 IP를 다시 쓰면서 원래 IP를 유지하면서 응답에 다시 쓰도록하는 기술이다.\n말만 들으면 정확하게 감이 잘 오지 않는다. 아래와 같은 네트워크 구성을 예로 들자면,\n이런 상황에서 Router가 모든 발신 패킷에 대해 NAT를 수행하도록 설정되어있다고 가정해보자. 보통의 라우터는\nIP Datagram 의 TTL을 하나 줄이고, checksum을 다시 계산하고, 원본 데이터를 수정하지 않은체로 패킷을 전달한다.\nNAT가 설정된 경우, 라우터는 소스 IP를 자신의 주소로 변경하고 패킷을 전달한다. 패킷을 받은 Computer2 는 Computer 1이 아닌 라우터가 해당 패킷을 보낸 것으로 확인하며, 응답을 Router의 IP 주소로 전달하게 될 것이다.\n라우터가 전달받은 응답이 실질적으로 Computer 1을 항햔다는 것을 안다면, 다시 Destination IP를 Computer 1의 주소로 변경하고 전달함으로써 통신이 정상적으로 동작하게 끔 할 수 있다. (다음 섹션인 NAT and the Transport Layer에서 확인)\n이런 과정을 통해 Computer 1의 IP 주소를 Computer 2에게 숨길 수가 있는데, 이 것을 IP masquerading 이라고 한다. 이를 통해 네트워크의 IP 주소를 외부로부터 숨길 수 있다. 이게 굉장히 중요한 보안 기법인데, 외부에서 클라이언트의 IP 주소를 모른다면 통신을 시도조차 할 수 없기 때문이다. 이런 네트워크를 one-to-many NAT 이라 한다.\nNAT and the Transport Layer NAT이 Network Layer에서 동작하면 그 과정은 쉽게 진행될 수 있다. Transport Layer에서 동작하게 된다면 NAT가 온전하게 동작하기 위한 추가적인 과정이 필요하게 된다.\n앞서 살핀것 처럼 단순히 외부로 나가는 OUTBOUND 패킷의 주소를 변경하는 일은 어렵지 않다. 외부로 부터 들어오는 INBOUND 패킷의 경우 모두 같은 주소 (라우터의 주소)를 통해 들어오게 되는데 이 패킷이 정확히 어떤 기기에 전달되어야 하는지 알아내야 한다.\nPort Preservation 클라이언트가 선택한 소스 포트가 라우터에서 사용하는 것과 동일한 포트인 기술\n(그림의 Destination IP는 Source IP로 변경되어야함. 오타)\n네트워크 외부와의 connection은 ephemeral port의 가능한 값 중에서 랜덤하게 선택되었었다. 클라이언트가 선택한 값을 라우터가 동일하게 사용한다. 라우터는 IP 주소만을 변경한다.\n전달받은 응답의 port를 통해 특정 컴퓨터에게 패킷을 전달 할 수 있다. 어떤 포트가 어떤 IP에 의해 사용되었는지는 라우터가 내부적으로 table을 통해 저장해야 할 것이다.\nephemeral port의 가능한 값은 충분히 다양하지만, 다른 컴퓨터에서 같은 포토를, 비슷한 시간대에 사용할 수도 있다. 이런 경우 라우터는 사용되지 않고 있는 랜덤한 포트를 대신 설정하고 사용한다.\nPort forwarding 특정 destination port가 항상 특정 node에게 전달될 수 있도록 하는 기술\n 기술의 핵심은, public ip 주소와 포트를 private ip와 포트로 전달할 수 있다는 점이다. 공유기에서 설정을 해줘야 한다.  port forwarding 은 IP masqurading 뿐만 아니라 더 유용하게 사용될 수 있다. 웹서버와 메일서버 각각이 다른 물리적 서버에서 동작할때, port forwarding을 통해 외부에서 서비스에 접속할때 같은 IP 주소로 port만 다르게 전달 함으로써 다른 서비스를 이용할 수 있다.\n대표적으로 같은 도메인 주소(같은 IP 주소)로 여러 서버, 여러 서비스를 운영하는 것이 가능하다. 외부에서 접근할때는 public ip (라우터 주소) 와 서비스의 포트만으로 서비스에 접근이 가능하다. (웹은 80포트, 이메일은 25포트와 같은식으로)\nOUTBOUND Packet의 경우 Port Preservation, INBOUND Packet의 경우 Port Forwarding를 이용함으로써 NAT를 통해 네트워크 통신이 가능하게 된다.\nNAT, Non routable address space and the limits of IPv4 IPv4 주소의 갯수는 한정되어 있고 점점 고갈되고 있다. IPv6가 현실적인 대안이지만 IPv6가 널리 쓰이기전까지, IPv4를 사용하면서도, 더 많은 기기들을 네트워크에 연결 가능하게 하려면 어떻게 해야할까?\n바로 앞에서 그것이 가능한 기술을 알아보았다. NAT 를 통해서는 하나의 public IP 주소를 통해 많은 기기들을 연결 할 수 있고, 네트워크 통신이 가능하게 한다. 네트워크 내부적으로는 Non routable address space를 사용하면서 외부에 공개된 라우터 만이 routable 한 address를 사용함으로써 이것이 가능하다.\n참고: IPv4 address exhaustion\nVPNs and Proxies Virtual Private Network 외부 host가 같은 로컬 네트워크에서 동작할 수 있도록 로컬 네트워크를 확장하는 기술\n네트워크 보안을 위해서는 Firewall, NAT 등의 기술등을 통해 내부 망에 연결되어 있는 기기들만이 자원에 접근이 가능하도록 구현을 하는 것이 좋다. 그럼에도 외부에서도 이런 자원을 접근할 필요가 있을 수 있는데, 그럴때 VPN을 사용한다.\n대부분의 VPN은 Transport Layer payload 내부에 제2의 패킷을 담는 것으로 구현된다.\nVPN은 two-factor authentication 이 가능하게 한 첫번쨰 기술이다.\nTwo-factor authentication 인증을 위해 username 과 패스워드 이상이 필요한 기술\n보통은 소프트웨어나 하드웨어의 특수한 부분을 활용해 짧은 단기간 사용할 수 있는 토큰을 만들고는 한다.\nVPN은 site와 site를 연결하는데에도 사용할 수 있다.\nNAT와 같이 VPN은 기술적인 컨셉일 뿐, 구체적인 사항이 모두 정의된 기술은 아니다.\nVPN의 가장 중요한 컨셉은 암호화된 커널을 이용해 실제로는 물리적으로 연결되어 있지 않은 네트워크 기기를 연결되어 있는 것처럼 사용하게 한다는 점이다.\nProxy Services 다른 서버에 접근하기 위해 클라이언트를 대신하여 작동하는 서비스\nProxy는 보통 아래의 이유들로 사용된다.\n Anonymity Security Content filtering Performance  Proxy는 그자체로 추상화된 개념으로, 구체적인 구현을 의미하는 것이 아니다.\nProxy는 거의 모든 Network layer에서 존재하며 수많은 예제가 존재한다.\nWeb Proxy 웹 서비스를 위한 프록시로, 다양한 역할을 수행할 수 있다.\n이전에는 Web Proxy가 클라이언트와 서버 사이에서 데이터를 전달하면서 캐싱등의 역할을 하기도 했다.\n요즘에는 네트워크도 빨라졌고, 페이지나 파일에 대한 캐싱이 큰 의미가 없어져서 큰 이득은 없다.\n클라이언트와 서버 사이에 Proxy가 웹 클라이언트가 특정 사이트, 주소로의 접근을 막는 등의 용도로 사용될 수도 있다.\nReverse proxy 하나의 서버를 가지는 것처럼 보이지만 여러 서버를 뒤에 두고 있는 서비스\ntwitter 같이 트래픽이 많은 서비스는 하나의 웹서버로는 그런 트래픽을 감당할 수 없을 것이다. 클라이언트의 입장에서는 모두 같은 서버에 접근하는 것으로 보이지만 Proxy 서버가 앞에서 많은 트래픽을 분산 시킴으로써 서버의 부하를 나눌 수 있다. DNS Round Robin과 같이 load balancing 의 일부이다.\n요즘 전달되는 웹 트래픽 대부분은 암호화가 되어있다. 이런 암호화를 해제하는 것 또한 많은 컴퓨팅 파워를 먹게 되는데, 이런일을 하도록 Proxy를 두고 Application Server 들은 실제 컨텐츠를 처리하는 것에만 집중하도록 서버를 구조화 할 수도 있다.\nProxy의 핵심 개념은 하나. 클라이언트와 다른 서버 사이의 중개자 역할을 하는 모든 서버는 Proxy라고 생각하면 된다.\nQUIZ  VPN은 대부분 transport layer에서 동작한다 (Not application layer) Name resolution 시 Anycast 를 통해 서버의 congestion을 줄일 수 있다. DNS는 사용자가 안전하게 연결 될 수 있게 한다. ?? NAT도 맞지 않나 DNS는 53포트를 사용한다.  Question  DHCP는 왜 application layer에서 도는가? transport layer에서 동작해도 충분하지 않나??  Not quite. Please review the videos in the “Introduction to Network Services” module for a refresher.\nREFERENCE  https://www.coursera.org/learn/computer-networking/home/week/4\n","wordCount":"2535","inLanguage":"korean","datePublished":"2020-06-21T00:00:00Z","dateModified":"2020-06-21T00:00:00Z","author":{"@type":"Person","name":"raeperd"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://raeperd.github.io/notes/network/network-services/"},"publisher":{"@type":"Organization","name":"raeperd.github.io","logo":{"@type":"ImageObject","url":"https://raeperd.github.io/favicon.ico"}}}</script>
</head>
<body id=top>
<script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script>
<noscript>
<style type=text/css>#theme-toggle,.top-link{display:none}</style>
<style>@media(prefers-color-scheme:dark){:root{--theme:#1d1e20;--entry:#2e2e33;--primary:rgba(255, 255, 255, 0.84);--secondary:rgba(255, 255, 255, 0.56);--tertiary:rgba(255, 255, 255, 0.16);--content:rgba(255, 255, 255, 0.74);--hljs-bg:#2e2e33;--code-bg:#37383e;--border:#333}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style>
</noscript>
<header class=header>
<nav class=nav>
<div class=logo>
<a href=https://raeperd.github.io/ accesskey=h title="raeperd.github.io (Alt + H)">raeperd.github.io</a>
<span class=logo-switches>
<button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg>
</button>
</span>
</div>
<ul id=menu onscroll=menu_on_scroll()>
<li>
<a href=https://raeperd.github.io/articles title=Article>
<span>Article</span>
</a>
</li>
<li>
<a href=https://raeperd.github.io/notes title=Note>
<span>Note</span>
</a>
</li>
<li>
<a href=https://raeperd.github.io/search title="Search (Alt + /)" accesskey=/>
<span>Search</span>
</a>
</li>
<li>
<a href=https://raeperd.github.io/archives/ title=Archives>
<span>Archives</span>
</a>
</li></ul>
</nav>
</header>
<main class=main><article class=post-single>
<header class=post-header>
<h1 class=post-title>
Network Services
</h1>
<div class=post-meta>
June 21, 2020&nbsp;·&nbsp;raeperd
</div>
<br>
<ul class=post-tags>
<li><a href=https://raeperd.github.io/tags/network/>network</a></li>
</ul>
</header>
<div class=post-content>
<h1 id=intro>INTRO<a hidden class=anchor aria-hidden=true href=#intro>#</a></h1>
<p>기초가 참 힘들다. 뭐든지 기초가 참 힘든거 같다. 퇴근하고 공부하는게 참 힘든일이긴 한데 그냥 코딩하는거면 어떻게든 재미를 찾을 수 있을 것 같은데 기초 공부라는게 되게 지루하다. 농구선수가 운동장 달리고 푸쉬업 하는 것처럼 기초는 중요하지만 귀찮고 재미없고 따분하기만 하다. 그래도 해야지 뭐 하면서 또 하게 된다. 잘 좀 하자.</p>
<h1 id=conetns>CONETNS<a hidden class=anchor aria-hidden=true href=#conetns>#</a></h1>
<h2 id=name-resolution>Name Resolution<a hidden class=anchor aria-hidden=true href=#name-resolution>#</a></h2>
<h3 id=why-do-we-need-dns>Why do we need DNS?<a hidden class=anchor aria-hidden=true href=#why-do-we-need-dns>#</a></h3>
<p>우리가 접속해야하는 사이트마다 IP 주소를 기억해야 한다고 생각하면 참 귀찮을 것이다. 사람들은 숫자를 기억하는 것보다 단어를 더 잘 기억한다. 그래서 IP 주소에 단어로 된 이름을 부여하는 것이 좋을 것.</p>
<h3 id=domain-name>Domain Name<a hidden class=anchor aria-hidden=true href=#domain-name>#</a></h3>
<p>DNS(Domain name system)에 의해 resolve 될 수 있는 용어.</p>
<p>모든 접속을 Domain Name으로 하도록 한다면, IP 주소가 바뀌더라도 사용자는 같은 방법으로 접근할 수 있다. 관리자는 DNS 로 해당하는 IP 주소만을 변경해주면 된다.</p>
<p>물리적으로 가까운 곳이면 당연히 통신은 빠를 것이다. 글로벌한 서비스를 제공하려면 하나의 서버가 아니라 분산되게 서버를 운영하는 것이 좋을 것. DNS는 다른 지역에서 접근하는 서비스들을 해당 지역에 맞는, 효율적인 IP 주소로 변경해줄 수 있다.</p>
<h3 id=the-many-steps-of-name-resolution>The Many Steps of Name Resolution<a hidden class=anchor aria-hidden=true href=#the-many-steps-of-name-resolution>#</a></h3>
<h3 id=name-resolution-1>Name resolution<a hidden class=anchor aria-hidden=true href=#name-resolution-1>#</a></h3>
<p>도메인 이름을 IP 주소로 변경하는 과정</p>
<p><strong>DNS 없이 네트워크는 동작하지만</strong> 컴퓨터를 사용하는 사람은 불편할 것이다. 설정해주는 것이 좋다.</p>
<p>총 5가지 종류의 DNS Server가 있다.</p>
<ol>
<li>Caching name servers</li>
<li>Recursive name servers</li>
<li>Root name servers</li>
<li>TLD name servers</li>
<li>Authoritative name servers</li>
</ol>
<h3 id=ttl-time-to-live>TTL (Time to live)<a hidden class=anchor aria-hidden=true href=#ttl-time-to-live>#</a></h3>
<p>초 단위로 도메인 네임을 얼마나 오래 저장할지를 나타낸다. 도메인 네임의 소유자가 설정할 수 있다.</p>
<ul>
<li>이전에는 트래픽을 줄이기 위해 하루 정도의 긴 값을 가졌다.</li>
<li>최근에는 몇분 혹은 몇시간 정도로 많이 설정되지만, 여전히 긴 경우도 발견할 수 있다.</li>
</ul>
<h3 id=anycast>Anycast<a hidden class=anchor aria-hidden=true href=#anycast>#</a></h3>
<ul>
<li>위치나 네트워크 상태등을 바탕으로 트래픽을 다른 목적지로 라우팅하는 기술이다.</li>
<li>이를 이용해 하나의 IP로 전달하는 패킷이 실제로는 다른 도착지로 전달될 수 있다.</li>
</ul>
<h3 id=tld-top-level-domain>TLD (Top-level domain)<a hidden class=anchor aria-hidden=true href=#tld-top-level-domain>#</a></h3>
<ul>
<li>도메인 이름의 마지막 부분</li>
<li><code>.com</code> 과 같은 부분
<img loading=lazy src=https://i.ibb.co/M89Qzs4/1-C6-F2-E5-A-8-B37-47-A4-AEE6-F4-E1515380-C9.png alt>
</li>
</ul>
<ol>
<li>Root Server 로부터 TLD name server 의 주소를 전달 받는다.</li>
<li>TLD Name Server 로부터 authoritative name server의 주소를 전달 받는다.</li>
<li>Query</li>
</ol>
<ul>
<li>Root Server와 TLD Name Server를 운영하는 곳은 적지만 Anycast와 같은 기술을 통해 물리적으로는 다른 주소로 트래픽이 redirect 된다.</li>
<li>이렇게 도메인 네임을 여러 단계로 얻어와야만 악의적인 공격자로 부터 안전하게 DNS 를 사용할 수 있다.</li>
</ul>
<h3 id=dns-and-udp>DNS and UDP<a hidden class=anchor aria-hidden=true href=#dns-and-udp>#</a></h3>
<p>DNS 는 TCP 대신 UDP 를 많이 쓴다. Name resolution에 드는 패킷의 차이가 많다.
<img loading=lazy src=https://i.ibb.co/N1rdnY7/34-D29208-AE1-B-435-A-92-F0-8-C563-E286-F77.png alt>
Name resolution의 한번의 요청과 응답의 경우, TCP connection 한번에 아래와 같은 송수신이 필요하다.</p>
<ul>
<li>3 way handshake</li>
<li>요청</li>
<li>요청을 받았다는 ack</li>
<li>응답</li>
<li>응답을 받았다는 ack</li>
<li>4 way-hand shake
=> 3 + 2 + 2 + 4 = 11</li>
</ul>
<p><img loading=lazy src=https://i.ibb.co/3Rf0XLJ/F6560-DD6-9-ADB-4-B7-A-AD86-92-DA8-F0-E49-AC.png alt>
반면 UDP 의 경우 주고 받는 패킷 하나씩 2번, 총 8개의 패킷 만으로 전체 Name resolution을 처리할 수 있다. 그래서 보통 DNS는 UDP를 많이 사용한다.</p>
<h2 id=name-resolution-in-practice>Name Resolution in Practice<a hidden class=anchor aria-hidden=true href=#name-resolution-in-practice>#</a></h2>
<p><img loading=lazy src=https://i.ibb.co/30ZP03t/BBC146-EE-00-C1-4-FA8-AFC5-62-C4-C1-A8-A3-AE.png alt>
</p>
<h3 id=resource-record-types>Resource Record Types<a hidden class=anchor aria-hidden=true href=#resource-record-types>#</a></h3>
<p>DNS가 정보를 기록하는 방식은 여러가지 방법이 있다.</p>
<h3 id=a-record>A record<a hidden class=anchor aria-hidden=true href=#a-record>#</a></h3>
<p>도메인 네임은 특정한 IPv4 주소를 가리키는데 사용된다.</p>
<ul>
<li>보통은 하나의 도메인 네임은 하나의 A record를 가진다.</li>
<li>하나의 도메인 네임이 여러개의 A record를 가질 수 있는데, 이를 통해 DNS Round robin이 가능하다.</li>
</ul>
<h3 id=dns-round-robin>DNS Round Robin<a hidden class=anchor aria-hidden=true href=#dns-round-robin>#</a></h3>
<ul>
<li>여러 IP를 반복하면서 DNS Name Resolution의 트래픽을 관리하는 방법.</li>
<li>하나의 DNS, microsoft.com에 IP 주소 4개의 A record를 가지게 했다고 가정해보자. 각각의 주소는 10.0.0.1 ~ 10.0.0.4이다. Name Resolution 요청에 DNS Resolver는 모든 IP 주소를 반환한다.</li>
<li>응답을 받은 컴퓨터는 자신이 전달받은 IP 주소 중 첫번째 주소(10.0.0.1)를 이용해야 한다는 것을 알고 있다. 그러나 첫번째 주소가 응답하지 않는 경우에 대비해서 주소 4개를 모두 가지고 있는다.</li>
<li>두번째로 microsoft.com 주소를 요청하는 컴퓨터 또한 마찬가지로 4가지 주소를 모두 전달받지만, 이번에 전달받은 주소의 첫번째 값은 10.0.0.1이 아닌 10.0.0.2 이다. 이 컴퓨터는 첫 연걸을 10.0.0.2 에 시도하게 되며, 이런 방식은 모든 DNS resolution 시도에서 동작하며, 트래픽을 분산시킨다.</li>
</ul>
<h3 id=quad-a-record>Quad A record<a hidden class=anchor aria-hidden=true href=#quad-a-record>#</a></h3>
<p>도메인 네임을 특정한 IPv6 주소를 가리키는데 사용한다.</p>
<h3 id=cname-record-canonical-name-record>CNAME record (Canonical name record)<a hidden class=anchor aria-hidden=true href=#cname-record-canonical-name-record>#</a></h3>
<ul>
<li>하나의 도메인에 다른 이름을 부여하는 방식</li>
<li>하나의 도메인을 다른 도메인으로 redirect 하는데 사용된다.</li>
<li>하나의 IP 주소가 여러 도메인을 가지도록 설정됬다고 해보자. 만약 IP 주소가 변경된다면 각각의 도메인의 A record를 변경하는 작업을 해야한다.</li>
<li>CNAME record를 이용해 대표 도메인을 설정하고, 다른 도메인들은 CNAME record를 통해 대표 도메인을 가리키도록 설정한다면 추후에 IP 주소가 변경되더라도 하나의 A record만 변경하는 것으로 수정을 최소화 할 수 있다.</li>
</ul>
<h3 id=mx-record-mail-exchange>MX record (Mail exchange)<a hidden class=anchor aria-hidden=true href=#mx-record-mail-exchange>#</a></h3>
<ul>
<li>e-mail을 올바른 서버로 전달하기 위해 사용되는 레코드</li>
<li>많은 회사들이 웹과 메일 서버를 다른 기기, 다른 IP 주소에서 서비스하게 된다. MX record 는 웹 트래픽은 웹서버, 메일 트래픽은 메일 서버에게 전달될 수 있도록 한다.</li>
</ul>
<h3 id=srv-record-service-record>SRV record (Service record)<a hidden class=anchor aria-hidden=true href=#srv-record-service-record>#</a></h3>
<ul>
<li>MX record와 유사하게 여러가지 서비스들의 위치들을 알아내는데 사용된다.</li>
<li>MX record와 동일하게 동작하는 대신, SRV record는 mail 서비스이외의 다른 종류의 서비스들에게 트래픽을 전달한다.</li>
</ul>
<h3 id=txt-record-text-record>TXT record (Text record)<a hidden class=anchor aria-hidden=true href=#txt-record-text-record>#</a></h3>
<ul>
<li>도메인 네임에 대해 사람이 읽을 수 있는 노트를 위한 record.</li>
<li>현대의 네트워크에서는 다른 컴퓨터가 처리할 수 있는 추가적인 정보를 많이 포함하기도 한다. 형식의 제한이 없는 record라 이를 이용해서 DNS가 원래 의도하지 않았던 추가적인 정보까지 전달하는 것이 가능하다.</li>
<li>신뢰된 다른 네트워크 서비스와 관련된 설정들을 공유하는데 사용되기도 한다. 예를 들면 이메일 서비스와 관련된 설정들을 공유하기도 한다고 하는데 눈으로 보고 코딩을 해보기전까지는 어떤 역할을 하는지 정확하게 감을 잡기는 힘들 것 같다.</li>
</ul>
<h3 id=anatomy-of-a-domain-name>Anatomy of a Domain Name<a hidden class=anchor aria-hidden=true href=#anatomy-of-a-domain-name>#</a></h3>
<p>모든 도메인은 세가지로 나뉜다.
1. subdomain (www) a.k.a hostname
2. domain (.google)
- TLD name server -> authoritive name server 사이의 전환에 사용
3. top-level domain (.com)
- ICANN 이라는 곳에서 관리한다.</p>
<ul>
<li>이 세가지를 모두 갖추면 FQDN(Fully qualified domain name) 이라불림</li>
<li>subdomain을 여러개 가지는것도 가능하다.</li>
<li>물론 글자수 등에 제한은 있다.</li>
</ul>
<p><code>subdomain.domain.top-level-domain</code> (ex <code>.help.acme.com</code>)</p>
<h3 id=dns-zones>DNS Zones<a hidden class=anchor aria-hidden=true href=#dns-zones>#</a></h3>
<p>DNS Zone은 Domain namesapce의 고유한 부분으로 DNS Zone을 유지 및 관리를 하는 개인, 조직, 회사에 위임된 도메인 네임 스페이스다.</p>
<ul>
<li>
<p>통상 DNS 서버 하나가 책임이나 권한을 가지는 영역을 말한다</p>
</li>
<li>
<p>여러 레벨의 도메인 네임을 더 다루기 쉽게 해주는 것이 목적</p>
</li>
<li>
<p>zone 은 겹치지 않는다.
<img loading=lazy src=https://i.ibb.co/7G2k4z0/8-D93-F3-FB-EF8-C-4988-A125-7-B398723-B0-E4.png alt>
</p>
</li>
<li>
<p>3개의 zone 과 하나의 대표 zone 으로 분리하면, 하나의 zone과 600개의 A record를 쓰는 것보다는 낫다.</p>
<ul>
<li>largecompany.com</li>
<li>la.largecompany.com</li>
<li>pa.largecompany.com</li>
<li>sh.largecompany.com</li>
</ul>
</li>
</ul>
<h3 id=root-name-server-root-zone>Root name server, Root zone<a hidden class=anchor aria-hidden=true href=#root-name-server-root-zone>#</a></h3>
<p>각각의 TLD 서버들은 특정 TLD의 zone들을 커버한다.</p>
<p>authoritatve name server 들은 더 세분화된 zone들을 커버한다.</p>
<h3 id=zone-files>Zone files<a hidden class=anchor aria-hidden=true href=#zone-files>#</a></h3>
<p>특정 zone에 대한 모든 resource record를 저장하고 있는 configuration file</p>
<h3 id=soa-record-start-of-authority>SOA record (Start of authority)<a hidden class=anchor aria-hidden=true href=#soa-record-start-of-authority>#</a></h3>
<p>zone과 해당 zone을 관리하는 name server의 이름이 저장되어 있는 record</p>
<p><strong>Zone file</strong> 이 가지고 있다.</p>
<h3 id=ns-record>NS record<a hidden class=anchor aria-hidden=true href=#ns-record>#</a></h3>
<p>이 zone을 책임지는 또 다른 name server 들을 가리키는 레코드</p>
<p>single point of failure 를 피하기위해 하나의 zone 을 여러 물리적 서버에서 관리할 수 있다.</p>
<h3 id=reverse-lookup-zone-files>Reverse lookup zone files<a hidden class=anchor aria-hidden=true href=#reverse-lookup-zone-files>#</a></h3>
<p>IP에 해당하는 FQDN(Full Qualified Domain Name)을 가지고 있는 파일</p>
<h3 id=pointer-resource-record>Pointer resource record<a hidden class=anchor aria-hidden=true href=#pointer-resource-record>#</a></h3>
<p>Resolves ip to a name.</p>
<h2 id=dynamic-host-configuration-protocol>Dynamic Host Configuration Protocol<a hidden class=anchor aria-hidden=true href=#dynamic-host-configuration-protocol>#</a></h2>
<h3 id=overview-of-dhcp>Overview of DHCP<a hidden class=anchor aria-hidden=true href=#overview-of-dhcp>#</a></h3>
<ul>
<li>IP</li>
<li>Subnet mask</li>
<li>Gateway</li>
<li>Name server</li>
</ul>
<p>네트워크 설정을 할떄, 반드시 설정해야하는 것들은 위 4가지 인데 여러 기기에 모두 설정하려면 귀찮은 일이 될 것 이다. 마지막 3개는 같은 네트워크 안이라면 보통 같을 것이다. IP는 달라져야 한다.</p>
<p>DHCP는 이런 귀찮은 일을 해주기 위해 필요하다.</p>
<h3 id=dhcp-dynamic-host-configuration-protocol>DHCP (Dynamic Host Configuration Protocol)<a hidden class=anchor aria-hidden=true href=#dhcp-dynamic-host-configuration-protocol>#</a></h3>
<p>호스트에서 네트워크 설정들을 자동으로 하게 해주기 위한 application layer protocol</p>
<ul>
<li>기기가 DHCP 서버에 네트웤 설정을 요청하면 네트웤 설정들을 한번에 받아올 수 있다.</li>
<li>관리자의 일을 줄여줄 뿐만 아니라 어떤 IP를 어떤 기기에 할당하는지 정하는 것도 설정할 수 있다.</li>
<li>DHCP가 네트워크 관리자가 해야하는 설정들을 자동으로 해주는 것 뿐만 아니라 IP를 어떻게 할당하는가에 대한 문제도 해결해 준다.</li>
</ul>
<p><strong>모든 기기의 모든 IP 들이 외부 네트워크로부터 공개될 필요는 없다. 서버 장비나 게이트웨이 라우터의 IP는 static 하고 public한 형태로 관리되어야 한다.</strong></p>
<p>예를 들면 같은 네트워크의 장비들은 게이트웨이의 주소를 항상 알고 있을 필요가 있다.</p>
<p>만약 로컬 DNS 서버가 동작하지 않는다고 해보자. 네트워크 관리자는 새로운 DNS 주소를 통해 문제를 해결 할 수 있을 것이다. DNS 서버를 static 하게 설정하지 않는다면, DNS 서버가 동작하지 않을때 문제점을 확인하는 것이 어려울 것이다.</p>
<p>그러나 다른 클라이언트 기기들은 올바른 네트워크 안에서 올바른 IP 주소를 가지고 있는가만 중요한 문제가 된다. 정확히 어떤 IP 주소를 가지느냐는 별로 중요하지 않다. DHCP를 사용하면 이러한 클라이언트 기기들을 위한 IP 주소들을 따로 할당해 둘 수 있다. 이런 방식으로 클라이언트 기기들은 필요할 때마다 IP 주소를 할당받을 수 있다. 그러면 모든 네트워크 장비들과 해당하는 IP 의 목록들을 관리할 필요가 없다.</p>
<p><strong>DHCP dynamic allocation</strong></p>
<p>A range of IP addresses is set aside for client devices and one of these IPs is issued to these devices when they request one.</p>
<p><strong>DHCP automatic allocation</strong></p>
<p>Automatic allocation is very similar to dynamic allocation, in that a range of IP addresses is set aside for assignment purposes. The main difference here is that the DHCP server is asked to keep track of which IPs it’s assigned to certain devices in the past. Using this information, the DHCP server will assign the same IP to the same machine each time, if possible.</p>
<p>(해석하는 것보다 원본이 더 의미를 잘 전달하는 것 같다)</p>
<p><strong>DHCP fixed allocation</strong></p>
<p>Fixed allocation requires a manually specified list of MAC address and the corresponding IPs.</p>
<ul>
<li>보안상의 목적으로 이렇게 쓰일 수 있다.</li>
</ul>
<p>NTP 서버를 할당하는 등에도 사용할 수 있다.</p>
<h3 id=dhcp-in-action>DHCP in Action<a hidden class=anchor aria-hidden=true href=#dhcp-in-action>#</a></h3>
<p>DHCP는 application layer 프로토콜이지만 DHCP의 포인트는 이 자체로 네트워크 레이어의 특징들을 결정하는데 있다. 아래와 같은 과정으로 설정을 공유할 수 있다.</p>
<h3 id=dhcpdiscover>DHCPDISCOVER<a hidden class=anchor aria-hidden=true href=#dhcpdiscover>#</a></h3>
<p><img loading=lazy src=https://i.ibb.co/KNmvpw7/4-D4-D4921-4-BBF-49-CB-8-E7-A-45-DD6-A3-EAF72.png alt>
</p>
<p>네트워크 설정을 얻기 위해 클라이언트의 시도</p>
<p>최초의 클라이언트는 항상 68포트로부터 67포트에게 브로드캐스트로 DHCPDISCOVER 메시지를 보낸다. Transport layer의 프로토콜은 UDP를 사용한다. 이런 메시지는 네트웤의 모든 노드에 전달되며 만약 DHCP 서버가 있다면 서버는 DHCPOFFER 메세지를 보낸다.</p>
<h3 id=dhcpoffer>DHCPOFFER<a hidden class=anchor aria-hidden=true href=#dhcpoffer>#</a></h3>
<p><img loading=lazy src=https://i.ibb.co/0tZxKrP/6-E3798-BF-CCD6-4476-9215-5-C7760249-D38.png alt>
</p>
<p>서버는 DHCPOFFER 메세지를 통해 클라이언트에게 IP 주소를 전달하는데 이 메세지의 패킷은 브로드캐스트로 전달된다. 최초의 DHCPDISCOVER 를 전송한 클라이언트는 DHCPOFFER 메세지에 포함되어있는, 요청을 보낸 클라이언트의 MAC 주소로부터 해당 DHCPOFFER 메시지가 자신에게 보내진 것임을 알 수 있다.</p>
<p>이떄 서버가 할당하는 IP 주소는 앞에서 알아본 allocation 설정이 어떻게 되어있느냐에 따라 할당된다.</p>
<p>클라이언트는 이런 DHCPOFFER 를 거절할 수 있는데, 여러 DHCP 서버가 네트워크에 있는 환경에서 특정 IP 주소를 거절하는 식으로 구현되기도 한다. 그러나 드문 케이스다. 클라이언트는 DHCPOFFER 메시지의 응답으로 DHCPREQUEST 메시지를 보낸다.</p>
<h3 id=dhcprequest>DHCPREQUEST<a hidden class=anchor aria-hidden=true href=#dhcprequest>#</a></h3>
<p><img loading=lazy src=https://i.ibb.co/kJ3wdg7/A6-DAB9-A7-2-D87-47-C9-80-CF-17373-D2-B2244.png alt>
</p>
<p>이 메시지는 보통 앞선 DHCPOFFER를 통해 할당된 IP 주소를 사용하겠다는 동의 의사를 전달하는데, 아직 IP의 할당이 완전하게 이루어진 것은 아니기 때문에 0.0.0.0:68 의 주소로, 브로드캐스트로 전달한다. 이후 서버는 DHCPACK 메시지로 응답한다.</p>
<h3 id=dhcpack>DHCPACK<a hidden class=anchor aria-hidden=true href=#dhcpack>#</a></h3>
<p><img loading=lazy src=https://i.ibb.co/6DSGcmq/D3-CD8-DF4-6-EB6-4-EB7-9055-A6-F5-C03-BC5-A0.png alt>
</p>
<p>DHCPOFFER와 마찬가지로 메시지에 포함되어 있는 MAC 주소를 통해 클라이언트는 본인에게 보내는 메시지임을 확인할 수 있다. 이제 클라이언트는 이제 DHCP Server를 통해 네트워크 설정을 할 수 있다.</p>
<p>이 단계에서 DHCP 클라이언트 역할을하는 컴퓨터에는 연결된 네트워크에서 본격적으로 작동하는 데 필요한 모든 정보가 있어야 한다. 이런 정보를 <strong>DHCP lease</strong> 라고 한다.</p>
<p>DHCP lease 는 expire time 을 가지고 있는데, 클라이언트가 가지고있는 lease가 파기되면 DHCP Discovery 부터 시작해서 다시 DHCP의 모든 과정을 반복해야한다.</p>
<p>클라이언트 또한 DHCP Server에게 lease 를 생성할 수 있는데, 네트워크로부터 disconnect를 할때 사용한다. 이 정보를 통해 DHCP server는 할당되었던 IP를 다시 재할당 가능한 IP pool에 추가할 수 있다.</p>
<h2 id=network-address-translation>Network Address Translation<a hidden class=anchor aria-hidden=true href=#network-address-translation>#</a></h2>
<h3 id=baiscs-of-nat>Baiscs of NAT<a hidden class=anchor aria-hidden=true href=#baiscs-of-nat>#</a></h3>
<p>게이트웨이(일반적으로 라우터 또는 방화벽)가 발신 IP 데이터 그램의 소스 IP를 다시 쓰면서 원래 IP를 유지하면서 응답에 다시 쓰도록하는 기술이다.</p>
<p>말만 들으면 정확하게 감이 잘 오지 않는다. 아래와 같은 네트워크 구성을 예로 들자면,</p>
<p><img loading=lazy src=https://i.ibb.co/1s4F7s8/E9508974-9485-4-B7-B-9-C87-0-A144-A80-F846.png alt>
</p>
<p>이런 상황에서 Router가 모든 발신 패킷에 대해 NAT를 수행하도록 설정되어있다고 가정해보자. 보통의 라우터는</p>
<p>IP Datagram 의 TTL을 하나 줄이고, checksum을 다시 계산하고, 원본 데이터를 수정하지 않은체로 패킷을 전달한다.</p>
<p><img loading=lazy src=https://i.ibb.co/vqRxRJx/0-BFEDD9-B-EEAC-4-DE0-B773-6-F2-EFFE84-A32.png alt>
</p>
<p>NAT가 설정된 경우, 라우터는 소스 IP를 자신의 주소로 변경하고 패킷을 전달한다. 패킷을 받은 Computer2 는 Computer 1이 아닌 라우터가 해당 패킷을 보낸 것으로 확인하며, 응답을 Router의 IP 주소로 전달하게 될 것이다.</p>
<p>라우터가 전달받은 응답이 실질적으로 Computer 1을 항햔다는 것을 안다면, 다시 Destination IP를 Computer 1의 주소로 변경하고 전달함으로써 통신이 정상적으로 동작하게 끔 할 수 있다. (다음 섹션인 NAT and the Transport Layer에서 확인)</p>
<p>이런 과정을 통해 Computer 1의 IP 주소를 Computer 2에게 숨길 수가 있는데, 이 것을 <strong>IP masquerading</strong> 이라고 한다. 이를 통해 네트워크의 IP 주소를 외부로부터 숨길 수 있다. 이게 굉장히 중요한 보안 기법인데, 외부에서 클라이언트의 IP 주소를 모른다면 통신을 시도조차 할 수 없기 때문이다. 이런 네트워크를 <strong>one-to-many NAT</strong> 이라 한다.</p>
<h3 id=nat-and-the-transport-layer>NAT and the Transport Layer<a hidden class=anchor aria-hidden=true href=#nat-and-the-transport-layer>#</a></h3>
<p>NAT이 Network Layer에서 동작하면 그 과정은 쉽게 진행될 수 있다. Transport Layer에서 동작하게 된다면 NAT가 온전하게 동작하기 위한 추가적인 과정이 필요하게 된다.</p>
<p>앞서 살핀것 처럼 단순히 외부로 나가는 OUTBOUND 패킷의 주소를 변경하는 일은 어렵지 않다. 외부로 부터 들어오는 INBOUND 패킷의 경우 모두 같은 주소 (라우터의 주소)를 통해 들어오게 되는데 이 패킷이 정확히 어떤 기기에 전달되어야 하는지 알아내야 한다.</p>
<h3 id=port-preservation>Port Preservation<a hidden class=anchor aria-hidden=true href=#port-preservation>#</a></h3>
<p>클라이언트가 선택한 소스 포트가 라우터에서 사용하는 것과 동일한 포트인 기술</p>
<p><img loading=lazy src=https://i.ibb.co/18Syc4c/C76218-F8-9-DF3-4777-AA6-C-B1921-BD24-BDA.png alt>
</p>
<p>(그림의 Destination IP는 Source IP로 변경되어야함. 오타)</p>
<p>네트워크 외부와의 connection은 ephemeral port의 가능한 값 중에서 랜덤하게 선택되었었다. 클라이언트가 선택한 값을 라우터가 동일하게 사용한다. 라우터는 IP 주소만을 변경한다.</p>
<p><img loading=lazy src=https://i.ibb.co/m5psZnz/EF9-D68-D6-1-B23-450-C-8663-FE20-D2-EB7-B66.png alt>
</p>
<p>전달받은 응답의 port를 통해 특정 컴퓨터에게 패킷을 전달 할 수 있다. 어떤 포트가 어떤 IP에 의해 사용되었는지는 라우터가 내부적으로 table을 통해 저장해야 할 것이다.</p>
<p>ephemeral port의 가능한 값은 충분히 다양하지만, 다른 컴퓨터에서 같은 포토를, 비슷한 시간대에 사용할 수도 있다. 이런 경우 라우터는 사용되지 않고 있는 랜덤한 포트를 대신 설정하고 사용한다.</p>
<h3 id=port-forwarding>Port forwarding<a hidden class=anchor aria-hidden=true href=#port-forwarding>#</a></h3>
<p>특정 destination port가 항상 특정 node에게 전달될 수 있도록 하는 기술</p>
<ul>
<li>기술의 핵심은, public ip 주소와 포트를 private ip와 포트로 전달할 수 있다는 점이다.</li>
<li><strong>공유기에서</strong> 설정을 해줘야 한다.</li>
</ul>
<p><img loading=lazy src=https://i.ibb.co/nCPYhpT/BC11-F99-E-C128-4-E45-BDDC-A04-CAD01-BCFE.png alt>
</p>
<p>port forwarding 은 IP masqurading 뿐만 아니라 더 유용하게 사용될 수 있다. 웹서버와 메일서버 각각이 다른 물리적 서버에서 동작할때, port forwarding을 통해 외부에서 서비스에 접속할때 같은 IP 주소로 port만 다르게 전달 함으로써 다른 서비스를 이용할 수 있다.</p>
<p>대표적으로 같은 도메인 주소(같은 IP 주소)로 여러 서버, 여러 서비스를 운영하는 것이 가능하다. 외부에서 접근할때는 public ip (라우터 주소) 와 서비스의 포트만으로 서비스에 접근이 가능하다. (웹은 80포트, 이메일은 25포트와 같은식으로)</p>
<p>OUTBOUND Packet의 경우 Port Preservation, INBOUND Packet의 경우 Port Forwarding를 이용함으로써 NAT를 통해 네트워크 통신이 가능하게 된다.</p>
<h3 id=nat-non-routable-address-space-and-the-limits-of-ipv4>NAT, Non routable address space and the limits of IPv4<a hidden class=anchor aria-hidden=true href=#nat-non-routable-address-space-and-the-limits-of-ipv4>#</a></h3>
<p>IPv4 주소의 갯수는 한정되어 있고 점점 고갈되고 있다. IPv6가 현실적인 대안이지만 IPv6가 널리 쓰이기전까지, IPv4를 사용하면서도, 더 많은 기기들을 네트워크에 연결 가능하게 하려면 어떻게 해야할까?</p>
<p>바로 앞에서 그것이 가능한 기술을 알아보았다. NAT 를 통해서는 하나의 public IP 주소를 통해 많은 기기들을 연결 할 수 있고, 네트워크 통신이 가능하게 한다. 네트워크 내부적으로는 Non routable address space를 사용하면서 외부에 공개된 라우터 만이 routable 한 address를 사용함으로써 이것이 가능하다.</p>
<p>참고: 
<a href=https://en.wikipedia.org/wiki/IPv4_address_exhaustion target=_blank>IPv4 address exhaustion</a></p>
<h2 id=vpns-and-proxies>VPNs and Proxies<a hidden class=anchor aria-hidden=true href=#vpns-and-proxies>#</a></h2>
<h3 id=virtual-private-network>Virtual Private Network<a hidden class=anchor aria-hidden=true href=#virtual-private-network>#</a></h3>
<p>외부 host가 같은 로컬 네트워크에서 동작할 수 있도록 로컬 네트워크를 확장하는 기술</p>
<p>네트워크 보안을 위해서는 Firewall, NAT 등의 기술등을 통해 내부 망에 연결되어 있는 기기들만이 자원에 접근이 가능하도록 구현을 하는 것이 좋다. 그럼에도 외부에서도 이런 자원을 접근할 필요가 있을 수 있는데, 그럴때 VPN을 사용한다.</p>
<p><img loading=lazy src=https://i.ibb.co/dBrVfMh/651-F65-E9-12-B9-4-CAA-9-B86-8-EC2-BFA7805-C.png alt>
</p>
<p>대부분의 VPN은 <strong>Transport Layer payload</strong> 내부에 제2의 패킷을 담는 것으로 구현된다.</p>
<p>VPN은 two-factor authentication 이 가능하게 한 첫번쨰 기술이다.</p>
<h3 id=two-factor-authentication>Two-factor authentication<a hidden class=anchor aria-hidden=true href=#two-factor-authentication>#</a></h3>
<p>인증을 위해 username 과 패스워드 이상이 필요한 기술</p>
<p>보통은 소프트웨어나 하드웨어의 특수한 부분을 활용해 짧은 단기간 사용할 수 있는 토큰을 만들고는 한다.</p>
<p>VPN은 site와 site를 연결하는데에도 사용할 수 있다.</p>
<p>NAT와 같이 VPN은 기술적인 컨셉일 뿐, 구체적인 사항이 모두 정의된 기술은 아니다.</p>
<p>VPN의 가장 중요한 컨셉은 암호화된 커널을 이용해 실제로는 물리적으로 연결되어 있지 않은 네트워크 기기를 연결되어 있는 것처럼 사용하게 한다는 점이다.</p>
<h3 id=proxy-services>Proxy Services<a hidden class=anchor aria-hidden=true href=#proxy-services>#</a></h3>
<p>다른 서버에 접근하기 위해 클라이언트를 대신하여 작동하는 서비스</p>
<p>Proxy는 보통 아래의 이유들로 사용된다.</p>
<ul>
<li>Anonymity</li>
<li>Security</li>
<li>Content filtering</li>
<li>Performance</li>
</ul>
<p>Proxy는 그자체로 추상화된 개념으로, 구체적인 구현을 의미하는 것이 아니다.</p>
<p>Proxy는 거의 모든 Network layer에서 존재하며 수많은 예제가 존재한다.</p>
<h3 id=web-proxy>Web Proxy<a hidden class=anchor aria-hidden=true href=#web-proxy>#</a></h3>
<p>웹 서비스를 위한 프록시로, 다양한 역할을 수행할 수 있다.</p>
<p><img loading=lazy src=https://i.ibb.co/6rPspjL/FF727-DE8-C46-F-4163-A5-FB-BBF9-CAE31-D93.png alt>
</p>
<p>이전에는 Web Proxy가 클라이언트와 서버 사이에서 데이터를 전달하면서 캐싱등의 역할을 하기도 했다.</p>
<p>요즘에는 네트워크도 빨라졌고, 페이지나 파일에 대한 캐싱이 큰 의미가 없어져서 큰 이득은 없다.</p>
<p><img loading=lazy src=https://i.ibb.co/Cw4kGnJ/DC7-C0621-E8-A4-420-C-849-E-6-A6-D282-B6-DC1.png alt>
</p>
<p>클라이언트와 서버 사이에 Proxy가 웹 클라이언트가 특정 사이트, 주소로의 접근을 막는 등의 용도로 사용될 수도 있다.</p>
<h3 id=reverse-proxy>Reverse proxy<a hidden class=anchor aria-hidden=true href=#reverse-proxy>#</a></h3>
<p>하나의 서버를 가지는 것처럼 보이지만 여러 서버를 뒤에 두고 있는 서비스</p>
<p><img loading=lazy src=https://i.ibb.co/7WHmqjN/CEF30082-A5-CC-4-BC1-82-B8-72-EE1664-E26-B.png alt>
</p>
<p>twitter 같이 트래픽이 많은 서비스는 하나의 웹서버로는 그런 트래픽을 감당할 수 없을 것이다. 클라이언트의 입장에서는 모두 같은 서버에 접근하는 것으로 보이지만 Proxy 서버가 앞에서 많은 트래픽을 분산 시킴으로써 서버의 부하를 나눌 수 있다. DNS Round Robin과 같이 load balancing 의 일부이다.</p>
<p><img loading=lazy src=https://i.ibb.co/mJJFJJd/D9-DDFE7-D-8-E67-45-A6-A127-F8-ED4-BC14991.png alt>
</p>
<p>요즘 전달되는 웹 트래픽 대부분은 암호화가 되어있다. 이런 암호화를 해제하는 것 또한 많은 컴퓨팅 파워를 먹게 되는데, 이런일을 하도록 Proxy를 두고 Application Server 들은 실제 컨텐츠를 처리하는 것에만 집중하도록 서버를 구조화 할 수도 있다.</p>
<p>Proxy의 핵심 개념은 하나. 클라이언트와 다른 서버 사이의 중개자 역할을 하는 모든 서버는 Proxy라고 생각하면 된다.</p>
<h1 id=quiz>QUIZ<a hidden class=anchor aria-hidden=true href=#quiz>#</a></h1>
<ul>
<li>VPN은 대부분 transport layer에서 동작한다 (Not application layer)</li>
<li>Name resolution 시 Anycast 를 통해 서버의 congestion을 줄일 수 있다.</li>
<li>DNS는 사용자가 안전하게 연결 될 수 있게 한다. ?? NAT도 맞지 않나</li>
<li>DNS는 53포트를 사용한다.</li>
</ul>
<h2 id=question>Question<a hidden class=anchor aria-hidden=true href=#question>#</a></h2>
<ul>
<li>DHCP는 왜 application layer에서 도는가? transport layer에서 동작해도 충분하지 않나??</li>
</ul>
<p>Not quite. Please review the videos in the “Introduction to Network Services” module for a refresher.</p>
<h1 id=reference>REFERENCE<a hidden class=anchor aria-hidden=true href=#reference>#</a></h1>
<p>
<a href=https://www.coursera.org/learn/computer-networking/home/week/4 target=_blank>https://www.coursera.org/learn/computer-networking/home/week/4</a></p>
</div>
<footer class=post-footer>
<div class=share-buttons>
<a target=_blank rel="noopener noreferrer" aria-label="share Network Services on twitter" href="https://twitter.com/intent/tweet/?text=Network%20Services&url=https%3a%2f%2fraeperd.github.io%2fnotes%2fnetwork%2fnetwork-services%2f&hashtags=network"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share Network Services on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fraeperd.github.io%2fnotes%2fnetwork%2fnetwork-services%2f&title=Network%20Services&summary=Network%20Services&source=https%3a%2f%2fraeperd.github.io%2fnotes%2fnetwork%2fnetwork-services%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share Network Services on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fraeperd.github.io%2fnotes%2fnetwork%2fnetwork-services%2f&title=Network%20Services"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share Network Services on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fraeperd.github.io%2fnotes%2fnetwork%2fnetwork-services%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share Network Services on whatsapp" href="https://api.whatsapp.com/send?text=Network%20Services%20-%20https%3a%2f%2fraeperd.github.io%2fnotes%2fnetwork%2fnetwork-services%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg>
</a>
<a target=_blank rel="noopener noreferrer" aria-label="share Network Services on telegram" href="https://telegram.me/share/url?text=Network%20Services&url=https%3a%2f%2fraeperd.github.io%2fnotes%2fnetwork%2fnetwork-services%2f"><svg viewBox="2 2 28 28"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg>
</a>
</div>
</footer><div id=disqus_thread></div>
<script>(function(){var a=document,b=a.createElement('script');b.src='https://raeperd-github-io.disqus.com/embed.js',b.setAttribute('data-timestamp',+new Date),(a.head||a.body).appendChild(b)})()</script>
<noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript>
</article>
</main><footer class=footer>
<span>&copy; 2021 <a href=https://raeperd.github.io/>raeperd.github.io</a></span>
<span>&#183;</span>
<span>Powered by <a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a></span>
<span>&#183;</span>
<span>Theme <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span>
</footer>
<a href=#top aria-label="go to top" title="Go to Top (Alt + G)">
<button class=top-link id=top-link type=button accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</button>
</a>
<script defer src=/assets/js/highlight.min.js onload=hljs.initHighlightingOnLoad()></script>
<script>window.onload=function(){localStorage.getItem("menu-scroll-position")&&(document.getElementById('menu').scrollLeft=localStorage.getItem("menu-scroll-position"))};function menu_on_scroll(){localStorage.setItem("menu-scroll-position",document.getElementById('menu').scrollLeft)}document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script>
<script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script>
<script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script>
</body>
</html>