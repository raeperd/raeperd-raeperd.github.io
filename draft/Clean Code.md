# Clean Code
#book #inbox #writings/blog

# 1 Clean code

일정에 쫓기더라도 대다수 관리자는 좋은 코드를 원한다. 그들이 일정과 요구사항을 강력하게 밀어 붙이는 이유는 그것이 그들의 책임이기 때문이다. 좋은 코드를 사수하는 일은 우리 프로그래머들의 책임이다.

어느 환자가 수술 전에 손을 씻지 말라고 요구한다. 시간이 너무 오래걸리니까. 확실히 환자는 상사다. 하지만 의사는 단호하게 거부한다. 왜? 질병과 감염의 위험은 환자보다 의사가 더 잘 아니까. 환자 말을 그대로 따르는 행동은 전문가 답지 못하다.

프로그래머도 마찬가지다. 나쁜 코드의 위험을 이해하지 못하는 관리자 말을 그대로 따르는 행동은 전문가 답지 못하다. 빨리 가는 유일한 방법은, 언제나 코드를 최대한 깨끗하게 유지하는 습관이다.

* 깨끗한 코드는 한가지를 제대로 한다.
* 깨끗한 코드는 잘 쓴 문장처럼 읽힌다.
* 깨끗한 코드는 다른 사람이 고치기 쉽다.
* 깨끗한 코드는 짐작한 대로 돌아간다.

코드를 읽는 시간 대 코드를 짜는 시간 비율이 10 대 1을 훌쩍 넘는다. 새 코드를 짜면서 우리는 끊임없이 기존 코드를 읽는다. 비율이 이렇게 높으므로 읽기 쉬운 코드가 매우 중요하다.

* 체크아웃할 때보다 좀 더 깨끗한 코드를 체크인 한다면 코드는 절대 나빠지지 않는다.
* 중복을 줄인다
* 표현력을 높인다
* 초반부터 간단한 초상화를 고려한다

# 2 Meaningful name
* 서로 흡사한 이름을 사용하지 않도록 주의한다.
* 의미가 불분명한 불용어는 사용하지 않는다.
	* info, data, a ,an ,the
* 발음하기 쉬운 단어를 선택한다.
* 검색하기 쉬운 이름을 사용한다.
	* 흔히 사용하는 상수들도 검색하기는 어려우므로 이름을 부여하는 편이 좋다
* Prefix, Postfix는 가능한한 피한다.
	* 클래스와 함수는 접두어가 필요없을 정도로 작아야 마땅하다.
	* 멤버 변수를 다른 색상으로 표시하거나 눈에 띄게 보여주는 IDE를 사용해야 마땅하다.
	* interface와 구현체의 구분은 굳이하자면 구현체에 `imple` postfix를 붙이는 것이 낫다.
		* 클래스가 인터페이스라는 사실을 독자에게 알릴 필요는 없다.
		* 독자가 인터페이스인지의 여부조차 궁금해할 필요가 없게끔 코드를 작성하는 것이 좋다.

# 3 Function
* 함수를 만드는 첫째 규칙은 "작게"다. 두번째 규칙은 "더 작게"다.
	* switch 문은 작게 만들기 어렵다. Factory 클래스를 구현하는 것이 아닌 곳에서는 피하도록 노력한다.
* 함수는 한가지를 해야한다. 그 한가지를 잘 해야 한다. 그 한가지만을 해야한다.
	* 객체 상태를 변경하거나 아니면 객체 정보를 반환하거나 둘 중 하나다. 둘 다 하면 혼란을 초래한다.
	* 오류 처리도 '한 가지' 작업에 속한다. 그러므로 오류를 처리하는 함수는 오류만 처리해야 마땅하다.
	* 함수가 확실히 "한 가지" 작업만 하려면 함수 내 모든 문장의 추상화 수준이 동일해야 한다.
	* 위에서 아래로 프로그램을 읽으면 함수 추상화 수준이 한 번에 한 단계씩 낮아진다.
* 이름이 길어도 괜찮다. 겁먹을 필요없다. 길고 서술저인 이름이 짧고 어려운 이름보다 좋다.
* 함수에서 이상적인 인수 개수는 0개다.
	* 인수는 어렵다. 인수는 함수를 이해하기 어렵게 만든다.
* 이벤트 함수는 조심해서 사용한다.
	* 이벤트라는 사실이 코드에 명확하게 드러나야 한다. 그러므로 이름과 문맥을 주의해서 선택한다.

어쩌면 중복은 소프트웨어에서 모든 악의 근원이다. 많은 원칙과 기법이 중복을 없애거나 제어할 목적으로 나왔다.

데이크스트라는 모든 함수와 함수 내 모든 블록에 입구와 출구가 하나만 존재해야 한다고 말했다. 즉, 함수는 return 문이 하나여야 한다는 말이다.

# 4 Comment
우리는 코드로 의도를 표현하지 못해, 그러니까 실패를 만회하기 위해 주석을 사용한다. 여기서 내가 실패라는 단어를 썼다는 사실에 주목한다. 진심이다. 주석은 언제나 실패를 의미한다. 때때로 주석 없이는 자신을 표현할 방법을 찾지 못해 할 수 없이 주석을 사용한다. 그래서 주석은 반겨 맞을 손님이 아니다.

# 5 Code formatting
코드 형식은 중요하다! 너무 중요해서 무시하기 어렵다. 너무나도 중요하므로 융퉁성 없이 맹목적으로 따르면 안 된다. 코드 형식은 의사소통의 일환이다. 의사소통은 전문 개발자의 일차적인 의무다.

* 서로 밀집한 개념은 세로로 가까이 둬야 한다.
	* 한 함수가 다른 함수를 호출한다면 두 함수는 세로로 가까이 배치한다.
	* 가능하다면 호출하는 함수를 호출되는 함수보다 먼저 배치한다. 그러면 프로그램이 자연스럽게 읽힌다. 규칙을 일관적으로 적용한다면, 독자는 방금 호출한 함수가 잠시 후에 정의되리라는 사실을 예측한다.
* 상수를 알아야 마땅한 함수에서 실제로 사용하는 함수로 상수를 넘겨주는 방법이 더 좋다.
* 정렬이 필요할 정도로 목록이 길다면 문제는 목록 길이지 정렬 부족이 아니다.

프로그래머라면 각자 선호하는 규칙이 있다. 하지만 팀에 속한다면 자신이 선호해야 할 규칙은 바로 팀 규칙이다.

# 6 Class and Data structure

* 절차적인 코드는 기존 자료 구조를 변경하지 않으면서 새 함수를 추가하기 쉽다. 반면, 객체 지향 코드는 기존 함수를 변경하지 않으면서 새 클래스를 추가하기 쉽다.
	* 다른 함수가 절차적인 프로그래밍의 자료구조 접근 방식처럼 비공개 변수를 사용하고픈 유혹에 빠지기 쉽상이다. (기능욕심 Feature envy)
	* 시스템을 구현할 때, 새로운 자료 타입을 추가하는 유연성이 필요하다면 객체가 더 적합하다. 다른 경우로 새로운 동작을 추가하는 유연성이 필요하면 자료구조와 절차적인 코드가 더 적합하다. 우수한 소프트웨어 개발자는 편견없이 이 사실을 이해해 직면한 문제에 최선인 해결책을 선택한다.
* 객체는 추상화 뒤로 자료를 숨긴 채 자료를 다루는 함수만 공개한다. 자료구조는 자료를 그대로 공개하며 별다른 함수는 제공하지 않는다.
	* 객체라면 뭔가를 하라고 말해야지 속을 드러내라고 말하면 안된다.
	* 자료구조는 별다른 동작 없이 자료를 노출한다. 그래서 기존 자료구조에 새 동작을 추가하기는 쉬우나, 기존 함수에 새 자료 구조를 추가하기는 어렵다.
* 디미터 법칙은 잘 알려진 휴리스틱으로, 모듈은 자신이 조작하는 객체의 속사정을 몰라야 한다는 법칙이다. 객체는 자료를 숨기고 함수를 공개한다. 객체는 조회 함수로 내부 구조를 공개하면 안된다.
	* 빈은 비공개 변수를 조회/설정 함수로 조작한다. 일종의 사이비 캡슐화로, 일부 OO 순수주의자나 만족시킬 뿐 별다른 이익을 제공하지 않는다.
	* 객체는 동작을 공개하고 자료를 숨긴다. 그래서 기존 동작을 변경하지 않으면서 새 객체 타입을 추가하기는 쉬운 반면, 기존 객체에 새 동작을 추가하기는 어렵다.

# 7 Error handling
반환값이 오류 코드인 경우 함수를 호출한 즉시 오류를 확인해야 한다. 불행히도 이 단계는 잊어버리기 쉽다. 그래서 오류가 발생하면 예외를 던지는 편이 낫다. 그러면 호출자 코드가 더 깔끔해진다. 논리가 오류처리 코드와 뒤섞이지 않으니까.

Checked Exception은 OCP 를 위반한다. 메소드에서 확인된 예외를 던졌는데 catch 블록이 세 단계 위에 있다면 그사이 메서드 모두가 선언부에 해당 예외를 정의해야 한다. 즉 하위 단계에서 코드를 변경하면 상위 단계 메서드 선언부를 전부 고쳐야 한다는 말이다.

# 8 Using external codes
패키지 제공자나 프레임워크 제공자는 적용성을 최대한 넓히려고 애쓴다. 더 많은 환경에서 돌아가야 더 많은 고객이 구매하니까. 반면 사용자는 자신의 요구에 집중하는 인터페이스를 바란다. 이런 긴장으로 인해 시스템 경계에서 문제가 생길 소지가 많다.

Map과 같은 경계 인터페이스를 이용할 때는 이를 이용하는 클래스나 클래스 계열 밖으로 노출되지 않도록 주의한다. Map 인스턴스를 공개 API의 인수로 넘기거나 반환값으로 사용하지 않는다.

학습 테스트는 프로그램에서 사용하려는 방식대로 외부 API를 호출한다. 통제된 환경에서 API를 제대로 이해하는지를 확인하는 셈이다. 학습 테스트는 API를 사용하려는 목적에 초점을 맞춘다.

# 9 Unit test
TDD 법칙 세가지

1. 실패하는 단위 테스트를 작성할 때까지 실제 코드를 작성하지 않는다.
2. 컴파일은 실패하지 않으면서 실행이 실패하는 정도로만 단위 테스트를 작성한다.
3. 현재 실패하는 테스트를 통과할 정도로만 실제 코드를 작성한다.

테스트 코드는 실제 코드 못지 않게 중요하다. 테스트 코드는 이류 시민이 아니다. 테스트 코드는 사고와 설계와 주의가 필요하다. 실제 코드 못지 않게 깨끗하게 짜야 한다.

깨끗한 테스트 코드를 만들려면?

* 세가지가 필요하다. 가독성, 가독성, 가독성.
* 어쩌면 가독성은 실제 코드보다 테스트 코드에 더더욱 중요하다. 여느 코드와 마찬가지로 명료성, 단순성, 풍부한 표현력이 필요하다. 테스트 코드는 최소의 표현으로 많은 것을 나타내야 한다.

테스트 함수마다 한 개념만 테스트 하라. 이것저것 잡다한 개념을 연속으로 테스트하는 긴 함수는 피한다. 한 테스트 당 하나의 assert도 좋은 규칙일 수 있다.

FIRST

* FAST
* Independent
* Repeatable
* Self-Validating
	* 테스트는 성공 아니면 실패여야 한다. 통과 여부를 알려고 로그 파일을 읽게 만들어서는 안된다.
* Timely

테스트 코드가 방치되어 망가지면 실제 코드도 망가진다. 테스트 코드를 깨끗하게 유지하자

# 10 Class
변수와 함수는 비공개 상태를 유지할 온갖 방법을 강구한다. 캡슐화를 풀어주는 결정은 언제나 최후의 수단이다.

클래스를 만들 때 첫 번째 규칙은 크기다. 클래스는 작아야 한다. 두 번째 규칙도 크기다.

클래스 이름은 해당 클래스 책임을 기술해야 한다. 실제로 작명은 클래스 크기를 줄이는 첫 번째 관문이다. 간결한 이름이 떠오르지 않는다면 필경 클래스 크기가 너무 커서 그렇다. 클래스 이름이 모호하다면 필경 클래스 책임이 너무 많아서다. 예를 들어, 클래스 이름에 Processor, Manager, Super 등과 같이 모호한 단어가 있다면 클래스가 여러 책임을 가지고 있다는 증거다.

클래스에 대한 설명은 if, and, or, but 을 사용하지 않고서 25단어 내외로 가능해야 한다.

SRP는 클래스나 모듈을 변경할 이유가 하나여야 한다는 원칙이다. 책임, 즉 변경할 이류를 파악하려 애쓰다 보면 코드를 추상화하기도 쉬워진다. 더 좋은 추상화가 더 쉽게 떠오른다.

문제는 우리들 대다수가 프로그램이 돌아가면 일이 끝났다고 여기는 데 있다. "깨끗하고 체계적인 소프트웨어"라는 다음 관심사로 전환하지 않는다. 프로그램으로 되돌아가 만능 클래스를 단일 책임 클래스 여럿으로 분리하는 대신 다음 문제로 넘어가버린다.

규모가 어느 수준에 이르는 시스템은 논리가 많고도 복잡하다. 이런 복잡성을 다루려면 체계적인 정리가 필수다. 그래야 개발자가 무엇이 어디에 있는지 쉽게 찾는다. 그래야 직접 영향이 미치는 컴포넌트만 이해해도 충분하다. 큼직한 다목적 클래스 몇 개로 이루어진 시스템은 당장 알 필요가 없는 사실까지 들이밀어 독자를 방해한다.

작은 클래스는 각자 맡은 책임이 하나며, 변경할 이유가 하나며, 다른 작은 클래스와 협력해 시스템에 필요한 동작을 수행한다.

클래스는 인스턴스 변수 수가 작아야 한다. 각 클래스 메서드는 클래스 인스턴스 변수를 하나 이상 사용해야 한다. 일반적으로 메서드가 변수를 더 많이 사용할수록 메서드와 클래스는 응집도가 더 높다. 모든 인스턴스 변수를 메스더마다 사용하는 클래스는 응집도가 가장 높다.

큰 함수를 작은 함수 여럿으로 나누기만 해도 클래스 수가 많아진다.

클래스 일부에서만 사용되는 비공개 메서드는 코드를 개선할 잠재적인 여지를 시사한다. 하지만 살제로 개선에 뛰어드는 계기는 시스템이 변해서라야 한다. 클래스에 손대는 순간 설계를 개선하려는 고민과 시도가 필요하다.

요구사항은 변하기 마련이다. 따라서 코드도 변하기 마련이다. 객체 지향 프로그래밍 입문에서 우리는 구체적인 클래스와 추상 클래스가 있다고 배웠다. 구체적인 클래스는 상세한 구현을 포함하며 추상 클래스는 개념만 포함한다고 배웠다. 상세한 구현에 의존하는 클라이언트 클래스는 구현이 바뀌면 위험에 빠진다. 그래서 우리는 인터페이스와 추상 클래스를 사용해 구현이 미치는 영향을 격리한다.

상세한 구현에 의존하는 코드는 테스트가 어렵다.

테스트가 가능할 정도로 시스템의 결합도를 낮추면 유연성과 자사용성도 더욱 높아진다.

결합도가 낮아지면 자연스럽게 DIP를 따르는 클래스가 나온다.

DIP는 클래스가 상세한 구현이 아니라 추상화에 의존해야 한다는 원칙이다.

# 11 System

## Lazy initialization

* 실제로 필요할 때까지 객체를 생성하지 않으므로 불필요한 부하가 걸리지 않는다.
* 어플리케이션이 시작하는 시간을 빠르게 할 수 있다.
* 명시적인 의존성이 생긴다.
* 테스트하기 어려워진다.

## main 분리
시스템 생성과 시스템 사용을 분리하는 한가지 방법으로, 생성과 관련된 코드는 모두 main이나 main이 호출하는 모듈로 옮기고, 나머지 시스템은 모든 객체가 생성되었고 모든 의존성이 연결되었다고 가정한다.

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/15cd9f41-6527-41a9-bb3d-39af40f504fe/Untitled.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/15cd9f41-6527-41a9-bb3d-39af40f504fe/Untitled.png]

어플리케이션은 main이나 객체가 생성되는 과정을 전혀 모르게 설계할 수 있고, 단지 모든 객체가 적절히 생성되었다고 가정한 코드를 작성할 수 있다.

## Dependency injection
사용과 제작을 분리하는 강력한 메커니즘 하나가 의존성 주입이다. 의존성 주입은 제어 역전 기법을 의존성 관리에 적용한 메커니즘이다. 제어 역전에서는 한 객체가 맡은 보조 책임을 새로운객체에게 전적으로 넘긴다. 새로운 객체는 넘겨받은 책임만 맡으므로 단일 책임 원칙을 지키게 된다. 의존성 관리 맥락에서 객체는 의존성 자체를 인스턴스로 만드는 책임을 지지 않는다. 대신에 이런 책임을 다른 '전담' 메커니즘에 넘겨야 한다. 그렇게 함으로써 제어를 역전한다. 초기 설정은 시스템 전체에 필요하므로 대게 '책임질' 메커니즘으로 'main' 루틴이나 특수 컨테이너를 사용한다.

클래스가 의존성을 해결하려 시도하지 않는다. 클래스는 완전히 수동적이다. 대신에 의존성을 주입하는 방법으로 Setter 메서드나 생성자 인수를 제공한다. DI 컨테이너는 (대게 요청이 들어올 때마다) 필요한 객체의 인스턴스를 만든 후 생성자 인수나 Setter 메서드를 사용해 의존성을 결정한다. 실제로 생성되는 객체 유형은 설정 파일에서 지정하거나 특수 생성 모듈에서 코드로 명시한다.

이렇게 의존성을 주입하는 방식으로 Lazy intialization 문제를 해결할 수 있지만, 항상 섣부른 최적화 일지 모른다는 사실을 명심해야한다.

## Expansion
소프트웨어의 확장에는 고통이 따른다. '확장' 공사로 꽉 막힌 도로에서 "왜 처음부터 넓게 만들지 않았지?" 라고 자문한 적이 얼마나 많던가?

하지만 다른 방식으로 확장이 일어나기는 어렵다. 성장할지 모른다는 기대로 자그만 마을에 6차선을 뚫는데 들어가는 비용을 정당화 할 수 있을까? 아니, 어느 조그만 마을이 6차선을 반길까?

"처음부터 올바르게" 시스템을 만들 수 있다는 믿음은 미신이다. 대신에 우리는 오늘 주어진 사용자 스토리에 맞춰 시스템을 구현해야 한다. 내일은 새로운 스토리에 맞춰 시스템을 조정하고 확장하면 된다. 이것이 반복적이고 점진적인 애자일 방식의 핵심이다. 테스트 주도 개발, 리팩터링, 깨끗한 코드는 코드 수준에서 시스템을 조정하고 확장하기 쉽게 만든다.

## Cross-cutting concern
영속성 프레임워크 또한 모듈화 할 수 있다. 도메인 논리도 독자적으로 모듈화 할 수 있다. 문제는 이 두 영역이 세밀한 단위로 겹친다는 점이다. AOP에서 관점이라는 모둘 구성 개념은 "특정 관심사를 지원하려면 시스템에서 특정 지점들이 동작하는 방식을 일관성 있게 바꿔야 한다"라고 명시한다. 명시는 간결한 선언이나 프로그래밍 메커니즘으로 수행한다.

코드 양과 크기는 프록시의 두가지 단점이다. 다시 말해서, 프록시를 사용하면 깨끗한 코드를 작성하기 어렵다. 또한 프록시는 시스템 단위로 실행 "지점"을 명시하는 메커니즘을 제공하지 않는다.

흔히 AOP를 구현하는 기법과 AOP 자체를 혼동한다. AOP 시스템의 진정한 가치는 시스템 동작을 간결하고 모듈화된 방식으로 명시하는 능력이다.

## Test driven system architecture
처음에 쏟아 부은 노력을 버리지 않으려는 심리적 저항으로 인해, 그리고 처음 선택한 아키텍처가 향후 사고 방식에 미치는 영향으로 인해, 변경을 쉽사리 수용하지 못한다.

최선의 시스템 구조는 각기 POJO 객체로 구현되는 모듈화된 관심사 영역(도메인)으로 구성된다. 이렇게 서로 다른 영역은 해당 영역 코드에 최소한의 영향을 미치는 관점이나 유사한 도구를 사용해 통합한다. 이런 구조 역시 코드와 마찬가지로 테스트 주도 기법을 적용할 수 있다.

# 12 Emergence
켄트 백이 제시한 단순한 설계 규칙 네가지

* 모든 테스트를 실행한다.
* 중복을 없앤다.
* 프로그래머 의도를 표현한다.
* 클래스와 메서드 수를 최소로 줄인다.

## 표현하라
자신이 이해하는 코드를 짜기는 쉽다. 코드를 짜는 동안에는 문제에 푹 빠져 코드를 구석구석 이해하니까. 하지만 나중에 코드를 유지보수할 사람이 코드를 짜는 사람만큼이나 문제를 깊이 이해할 가능성은 희박하다.

1. 좋은 이름을 선택한다.
2. 함수와 클래스 크기를 가능한 줄인다.
3. 표준 명칭을 사용한다.
4. 단위 테스트 케이스를 꼼꼼히 작성한다.

표현력을 높이는 가장 중요한 방법은 노력이다. 흔히 코드만 돌린 후 다음 문제로 직행하는 사례가 너무나도 흔하다. 나중에 읽을 사람을 고려해 조금이라도 읽기 쉽게 만드려는 충분한 고민은 거의 찾기 힘들다. 하지만 나중에 코드를 읽을 사람은 바로 자신일 가능성이 높다는 사실을 명심하자.

그러므로 자신의 작품을 조금 더 자랑하자. 함수와 클래스에 조금 더 시간을 투자하자. 더 나은 이름을 선택하고, 큰 함수를 작은 함수 여럿으로 나누고, 자신의 작품에 조금먼

경험을 대신할 단순한 개발 기법이 있을까? 당연히 없다. 하지만 이 장, 아니 이 책에서 소개하는 기법은 저자들이 수십 년 동안 쌓은 경험의 정수다. 단순한 설계 규칙을 따른다면, 우수한 기법과 원칙을 단번에 활용할 수 있다.

# 14 Progressive improvement
단순히 돌아가는 코드에 만족하는 프로그래머는 전문가 정신이 부족하다. 설계와 구조를 개선할 시간이 없다고 변명할지 모르지만 나로서는 동의하기 어렵다. 나쁜 코드보다 더 오랫동안 더 심각하게 개발 프로젝트에 악영향을 미치는 요인도 없다. 나쁜 일정은 다시 짜면 된다. 나쁜 요구사항은 다시 정의하면 된다. 나쁜 팀 역햑은 복구하면 된다. 하지만 나쁜 코드는 썩어 문드러진다. 점점 무게가 늘어나 팀의 발목을 잡는다. 속도가 점점 느려지다 못해 기어가는 팀도 많이 봤다. 너무 서두르다가 이후로 영원히 자신들의 운명을 지배할 악성 코드라는 굴레를 짊어진다.

반면 처음부터 코드를 깨끗하게 유지하기란 상대적으로 쉽다. 아침에 엉망으로 만든 코드를 오후에 정리하는 것은 어렵지 않다. 더욱이 5분전에 엉망으로 만든 코드는 지금 당장 정리하기 아주 쉽다.

# 17 Smells and heuristic
* 빌드는 간단히 한 단계로 끝나야 한다.
* 모든 단위 테스트는 한 명령으로 돌려야 한다.
* 함수에서 인수 개수는 적을수록 좋다.
* 함수나 클래스는 다른 프로그래머가 당연하게 여길 만한 동작과 기능을 제공해야 한다.
* 모든 경계 조건을 찾아내고, 모든 경계 조건을 테스트하는 테스트 케이스를 작성하라.
* 버그 주변을 철저히 테스트 해라. 버그는 서로 모이는 경향이 있다. 한 함수에서 버그를 발견했다면 그 함수를 철저히 테스트하는 편이 좋다.