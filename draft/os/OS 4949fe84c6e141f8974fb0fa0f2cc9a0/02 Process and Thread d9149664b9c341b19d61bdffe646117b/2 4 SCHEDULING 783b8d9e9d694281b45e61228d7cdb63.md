# 2.4 SCHEDULING

---

# 2.4 SCHEDULING

- 프로세스의 순서를 결정하는 운영체제의 일부를 스케쥴러라 한다.
- 스케쥴링은 보통 스레드 단위로 이루어 진다. 어떤 프로세스 이던 큰 상관안함

## 2.4.1 Introduction to Scheduling

### Process Behavior

- CPU-bound and I/O-bound
- I/O-bound가 빨리 일해야 느린 디스크가 안놀 수 있다.

### When to Schedule

1. 프로세스가 생성될 때
2. 프로세스가 종료할 때 
3. 프로세스가 I/O, 세마포어, 또는 다른 무언가로 대기할 때 
4. I/O 인터럽트가 발생했을 때 
5. 선점형 스케쥴링 알고리즘의 경우 클럭 인터럽트가 발생했을 때 

### Categories of Scheduling Algorithms

1. Batch 
2. Interactive 
3. Real time 

Batch 는 하나의 프로세스가 오래 써도 괜찮은 구조임

### Scheduling Algorithm Goals

**All systems**

- Fair ness - giving each process a fair share of the CPU
- Policy enforcement - seeing that stated policy is carried out
- Balance - keeping all parts of the system busy

**Batch systems**

- Throughput - maximize jobs per hour
- Turnaround time - minimize time between submission and termination
- CPU utilization - keep the CPU busy all the time

**Interactive systems**

- Response time - respond to requests quickly
- Propor tionality - meet users’ expectations

**Real-time systems**

- Meeting deadlines - avoid losing data
- Predictability - avoid quality degradation in multimedia systems

모든 상황에서 fairness가 가장 중요하다. 

시스템의 모든 부분이 최대한 바쁘게 하고싶다. 

CPU-bound 프로세스와 I/O-bound 프로세스가 동시에 메모리에 올라왔으면 좋겠다. 

Throughput:

시간당 시스템이 완료한 작업의 수 

Turnaround Time:

작업이 요청된 뒤부터 완료될 때 까지의 시간

CPU Utilization:

Response time:

Proportionality:

사용자의 기대

## 2.4.2 Scheduling in Batch Systems

### First-com, First-served

![2%204%20SCHEDULING%20783b8d9e9d694281b45e61228d7cdb63/Untitled.png](2%204%20SCHEDULING%20783b8d9e9d694281b45e61228d7cdb63/Untitled.png)

- easy to program, easy to understand

### Shortest Job First

![2%204%20SCHEDULING%20783b8d9e9d694281b45e61228d7cdb63/Untitled%201.png](2%204%20SCHEDULING%20783b8d9e9d694281b45e61228d7cdb63/Untitled%201.png)

![2%204%20SCHEDULING%20783b8d9e9d694281b45e61228d7cdb63/Untitled%202.png](2%204%20SCHEDULING%20783b8d9e9d694281b45e61228d7cdb63/Untitled%202.png)

- 모든 작업이 동시에 수행 가능할때는 이것이 최적의 방법이다.

### Shortest Remaining Time Next

![2%204%20SCHEDULING%20783b8d9e9d694281b45e61228d7cdb63/Untitled%203.png](2%204%20SCHEDULING%20783b8d9e9d694281b45e61228d7cdb63/Untitled%203.png)

## 2.4.3 Scheduling in Interactive Systems

### Round-Robin Scheduling

![2%204%20SCHEDULING%20783b8d9e9d694281b45e61228d7cdb63/Untitled%204.png](2%204%20SCHEDULING%20783b8d9e9d694281b45e61228d7cdb63/Untitled%204.png)

- 각 프로세스가 수행 가능한 기간을 할당받음
- 끝나가는 프로세스가 아슬아슬하게 안끝나면 피곤한 일임
- 단위 시간을 너무 짧게 잡으면 프로세스가 너무 많이 전환되 CPU 효율이 안나옴
- 단위 시간을 너무 길게 잡으면 즉각적인 반응을 바라는 프로세스는 반응이 늦을 것

### Priority Scheduling

![2%204%20SCHEDULING%20783b8d9e9d694281b45e61228d7cdb63/Untitled%205.png](2%204%20SCHEDULING%20783b8d9e9d694281b45e61228d7cdb63/Untitled%205.png)

- 우선순위에 따라 스케쥴링 하자
- 실행중인 프로세스의 우선순위를 실행시간에 비례해서 떨어뜨릴 수도 있다.
- 우선순위는 정적, 동적으로 할당할 수 있다.
- I/O-bound 프로세스를 기다리게 하는 것은 쓸때없이 메모리에서 너무 오래 기다리게 한다.

### Multiple Queues

- CPU-bound 프로세스에게 더 많은 시간 단위를 할당해 주자
- 우선순위가 높은 클래스로부터 내려오면 더 많은 시간을 할당해 주자 (반응을 원할테니)

### Shortest Process Next

![2%204%20SCHEDULING%20783b8d9e9d694281b45e61228d7cdb63/Untitled%206.png](2%204%20SCHEDULING%20783b8d9e9d694281b45e61228d7cdb63/Untitled%206.png)

- 프로세스의 실행시간을 추정해야 하네
- 이전의 행동에 기반해 실행시간을 추정하고 이게 젤 짧은 놈 부터 실행하자.
- aging:
    - Sn+1 = aTn + (1-a)Sn

### Guaranteed Scheduling

- 1/n 의 자원을 프로세스 마다 보장해주자.

### Lottery Scheduling

- 프로세스에게 CPU를 할당받을 수 있는 확률을 주자.
- 이 확률을 주고 받음으로써 우선순위를 동적으로 할당할 수 있다.

### Fair-Share Scheduling

![2%204%20SCHEDULING%20783b8d9e9d694281b45e61228d7cdb63/Untitled%207.png](2%204%20SCHEDULING%20783b8d9e9d694281b45e61228d7cdb63/Untitled%207.png)

- 유저 마다 프로세스를 가지고 있을 것
- 유저에게 자원을 공평하게 분배하자

## 2.4.4 Scheduling in Real-Time Systems

- 응답이 늦는게 안받느니만 못한 상황이 많음
- hard real time & soft real time

    ![2%204%20SCHEDULING%20783b8d9e9d694281b45e61228d7cdb63/Untitled%208.png](2%204%20SCHEDULING%20783b8d9e9d694281b45e61228d7cdb63/Untitled%208.png)

- 스케쥴 가능한지 확인하는 판별식도 있음!

## 2.4.5 Policy Versus Mechanism

## 2.4.6 Thread Scheduling

![2%204%20SCHEDULING%20783b8d9e9d694281b45e61228d7cdb63/Untitled%209.png](2%204%20SCHEDULING%20783b8d9e9d694281b45e61228d7cdb63/Untitled%209.png)

### User-level thread

- 클락 인터럽트가 없어서 하나의 쓰레드가 오래 돌 수도 있지만 쓰레드는 보통 협력 관계이기 때문에 큰 문제가 되지는 않음
- kernel-level과의 성능차이
- 어플리케이션에 특화된 스케쥴러를 직접 구현할 수도 있다.

### Kernel-level thread

- user-level thread와 달리 thread I/O 가 프로세스의 동작을 suspend 시키지는 않는다.
- 커널은 프로세스의 쓰레드에서 다른 프로세스의 쓰레드로의 스위칭이 비싼 것을 알기에 이를 반영할 수도 있다.

## Traditional Unix Scheduling

- Multilevel feedback using round robin within each of the priority queues
- 실행중인 프로세스가 1초안에 완료 혹은 블락 되지 않으면 preempted
- 우선순위는 매초 다시 계산된다.
- 기준 우선순위는 모든 프로세스를 고정된 우선순위 레벨로 나눈다.

![2%204%20SCHEDULING%20783b8d9e9d694281b45e61228d7cdb63/Untitled%2010.png](2%204%20SCHEDULING%20783b8d9e9d694281b45e61228d7cdb63/Untitled%2010.png)

### Bands

- Decreasing order of priority
    - swapper
    - block I/O device control
    - file manipulation
    - character I/O device control
    - user process