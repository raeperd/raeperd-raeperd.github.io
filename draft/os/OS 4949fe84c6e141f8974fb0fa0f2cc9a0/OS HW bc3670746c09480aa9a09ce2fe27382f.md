# OS HW

운영체제 과제 (마감일: 5월 17일 오후 5시, 제출장소: 정보기술관 309호(문 밑으로 밀어 넣을 것))

### 필독)

1) 모든 학생은 문서 형태의 보고서를 제출한다. 소스 코드가 담긴 USB나 CD-ROM은 제출하지 않는다.

2) 보고서에는 프로그램 소스와 프로그램 수행 결과가 인쇄되어 있어야 한다. 손으로 작성한 보고서는 인정하지 않는다.

3) 프로그램 수행 결과는 화면 출력을 캡쳐해서 작성한다.

4) 화면 출력을 캡쳐한 프로그램 수행 결과에는 학생의 학번과 이름이 포함되어 있어야 한다

.5) 첨부한 예제 프로그램은 C#이다. 그러나 `CompareExchange()`를 지원하는 다른 언어로 과제를 수행하여결과를 제출해도 된다.

### detail

첨부한 예제 프로그램은 Visual Studio의 Console 앱으로 동작하는 C# 프로그램이다.예제를 보면, `Interlocked.CompareExchange()` 함수를 사용하여 스트링이나 정수를 변경한다.

`Interlocked.CompareExchange(ref i, newVal, oldVal)`는i 값이 oldVal 이면 newVal로 변경하는데, 이 모든 동작이 atomic 하게 수행된다.

1) 첨부한 프로그램에서 여러 개(다수의 스레드에서 실험할 것)의 스레드들이루프를 돌면서 AddVal(1) 함수를 호출하여 원자적으로 값을 증가시킬 때와 단순히 덧셈 연산(i +=1 또는 i++)으로 값을 증가시킬 때 차이가 있는지확인하라. 프로그램과 결과(화면 캡쳐 또는 프로그램 출력)를 보고서에 기술하라. 

- 2만이 되야함 그냥 증가시키면 2만 안될 것임

2) `Interlocked.CompareExchange()`를 이용하여 자료구조 시간에 배운Linked List 자료구조를 구현하라.다수의 스레드가 리스트에 노드를 삽입하고 제거하는 동작을 수행하여문제가 없는지 확인하라. 프로그램과 실험 결과(화면 캡쳐 또는 프로그램 출력)를 보고서에 기술하라.주의) ABA problem이 발생할 수 있다. ABA 문제를 해결책을 적용하여 구현하라.

3) 노드 삽입, 삭제시 뮤텍스 락과 언락으로 상호배제 하는 기법은 다음과 같다. mutex_lock() 노드 삽입 또는 삭제 mutex_unlock()

위 기법과 `CompareExchange()`를 사용하는 기법의 성능을 비교하라.

```csharp
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading;
using System.Threading.Tasks;

namespace Test2019
{
    class Program
    {
        private static string _str = "abc";
        private static int _val = 0;

        static void AppendStr(string newstr)
        {
            while (true)
            {
                var original = Interlocked.CompareExchange(ref _str, null, null);
                var newString = original + newstr;
                if (Interlocked.CompareExchange(ref _str, newString, original) == original)
                    break;
            }
        }

        static void AddValue(int value)
        {
            while (true)
            {
                var orgVal = _val;
                var newVal = orgVal + value;
                if (Interlocked.CompareExchange(ref _val, newVal, orgVal) == orgVal)
                    break;
            }
        }

        static void ThreadBody()
        {
            for (int i = 0; i < 100000; i++)  // Main 스레드와 병행 수행
                AddValue(1);
        }

        static void Main(string[] args)
        {
            Console.WriteLine("Hello");
            AppendStr("xx");
            Console.WriteLine(_str);
//            AddValue(5);
//            Console.WriteLine(_val);

            Thread t = new Thread(ThreadBody);
            t.Start();

            for (int i = 0; i < 100000; i++)  // 스레드 t와 병행 수행
                AddValue(1);

            t.Join();
            Console.WriteLine(_val);
        }
    }
}
```