# Week4 One-vs-All

# Summary

- 행렬 차원 생각해서 곱하는게 너무 tricky 하다.
- 귀찮은 debugging 을 반복해야함 한방에 따딲딲 됬으면 좋겠다.

# IrCostFunction.m

```matlab
function [J, grad] = lrCostFunction(theta, X, y, lambda)
J = 0;
grad = zeros(size(theta));

% operation here
[J, grad] = costFunctionReg(theta, X, y, lambda);

grad = grad(:); % change grad as column vector 

end

```

- 저번 과제를 벡터화 해서 풀었기 때문에 날로 먹음

# oneVsAll.m

```matlab
function [all_theta] = oneVsAll(X, y, num_labels, lambda)

m = size(X, 1);
n = size(X, 2);

all_theta = zeros(num_labels, n + 1);

% Add ones to the X data matrix because of hidden unit
X = [ones(m, 1) X];

% operation here 
inital_theata = zeros(n+1, 1);
options = optimset('GradObj', 'on', 'MaxIter', 30);

for i= 1:num_labels
    all_theta(i,:) = fmincg (@(t)(lrCostFunction(t, X, (y == i), lambda)),inital_theata, options);
end
```

- `all_theta(i,:)` 로 matrix의 모든 row를 바꿀 수 있다.
    - 이거 떄문에 몇시간을 날린지 모르겠ㄷ.

# predict.m

```matlab
function p = predict(Theta1, Theta2, X)

m = size(X, 1);
num_labels = size(Theta2, 1);

X = [ones(m, 1) X];

% operation here
a2 = sigmoid(X*Theta1');

n = size(a2,1);
a2 = [ones(n,1) a2];

a3 = sigmoid(a2*Theta2');

[~,p] = max(a3, [], 2);

end
```

- `[~,p] = max(a3, [], 2);` : row 별로 최댓값을 가지는 인덱스를 반환

# predictOneVsAll.m

```matlab
function p = predictOneVsAll(all_theta, X)
m = size(X, 1);
num_labels = size(all_theta, 1);

% You need to return the following variables correctly 
p = zeros(size(X, 1), 1);

% Add ones to the X data matrix
X = [ones(m, 1) X];

% real operation
[~,p] = max(sigmoid(X*all_theta'), [], 2);
end
```