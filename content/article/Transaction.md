---
title: "Transaction in bitcoin"
date: 2020-03-25
author: raeperd
tags: ["blockchain", "cryptography"]
cover:
  image: /cover/blockchain.png
---

# INTRO

 블록체인이 어떤 것인지 대충 감은 잡고 있다고 생각했고 이렇게 저렇게 하면 금방 만들 수 있겠지 하고 생각했는데, 생각보다 정교하고 잘 짜여져있는 구조라는 걸 공부하면 할 수록 알게되네요. 정말 블록체인은 암호화폐가 맞긴 한가봅니다. 이제서야 왜 다들 블록체인 블록체인 하는지 조금은 알게 되는것 같습니다. 

 이 글은 단지 [Mastering Bitcoin](https://github.com/bitcoinbook/bitcoinbook)을 참고해서 공부하면서 Transaction에 대해 나름대로 이해한 내용을 정리한 것입니다. 정리가 목적인 글이라 포스팅의 설명은 친절하지 않을 것이구요, 더 자세한 이해를 위해서는 책을 보시면 좋을 것 같습니다. 번역도 꽤 잘되있습니다. [비트코인, 블록체인과 금융의 혁신](http://www.yes24.com/Product/Goods/22357437) 이라는 책입니다.

이제 막 블록체인을 접하신 분들이라면, [Youtube | But how does bitcoin actually work?](https://www.youtube.com/watch?v=bBC-nXj3Ng4&t=1020s) 영상을 추천합니다.

# 거래구조

 앞서 언급한대로 블록체인에 올라오는 거래는 우리가 아는 내용과는 달리 조금 복잡한 구조를 가집니다. 단순히 보내는 사람, 받는 사람, 돈의 액수, 그리고 기껏 더해봐야 서명정도 있을 것이라 생각했는데 실제 비트코인에서의 raw transaction은 아래와 같은 형태를 지니고 있습니다. 

```json
{
  "version": 1,
  "locktime": 0,
  "vin": [
    {
      "txid": "7957a35fe64f80d234d76d83a2a8f1a0d8149a41d81de548f0a65a8a999f6f18",
      "vout": 0,
      "scriptSig" : "3045022100884d142d86652a3f47ba4746ec719bbfbd040a570b1deccbb6498c75c4ae24cb02204b9f039ff08df09cbe9f6addac960298cad530a863ea8f53982c09db8f6e3813[ALL] 0484ecc0d46f1918b30928fa0e4ed99f16a0fb4fde0735e7ade8416ab9fe423cc5412336376789d172787ec3457eee41c04f4938de5cc17b4a10fa336a8d752adf",
      "sequence": 4294967295
    }
  ],
  "vout": [
    {
      "value": 0.01500000,
      "scriptPubKey": "OP_DUP OP_HASH160 ab68025513c3dbd2f7b92a94e0581f5d50f654e7 OP_EQUALVERIFY OP_CHECKSIG"
    },
    {
      "value": 0.08450000,
      "scriptPubKey": "OP_DUP OP_HASH160 7f9b1a7fb68d60c536c2fd8aeaa53a8f3cc025a8 OP_EQUALVERIFY OP_CHECKSIG",
    }
  ]
}
```

각 필드는 대략 아래와 같은 특징을 가집니다. ​    

| 크기     | 필드          | 설명                           |
| -------- | ------------- | ------------------------------ |
| 4 byte   | 버전          | 해당 거래가 따르는 규칙을 명시 |
| 1~9 byte | 입력값 카운터 | 포함된 입력값의 갯수           |
| 가변적   | 입력값        | 하나 이상의 거래 입력값        |
| 1~9 byte | 출력값 카운터 | 포함된 출력값의 갯수           |
| 가변적   | 출력값        | 하나 이상의 출력값             |
| 4 byte   | 잠금 시간     | 유닉스 타임스탬프나 블록 개수  |

 



## 거래 출력값과 입력값

### UTXO (Unspent Transaction output) 

- 특정 소유주에 대해 암호로 잠겨 있고, 블록체인상에 기록되어 있으며  전체 네트워크에 의해 통화 단위로 인정받은 불가분의 비트코인 통화 덩어리
- ==비트코인 네트워크 내에서 화폐의 단위는 비트코인이 아니라 UTXO 이다.==
- UTXO가 가장 기본적인 단위로 이를 쪼갤 수 없다. 더 작은 단위의 거래를 원한다면 출력값을 늘림으로써 이를 해결한다. 
- 가령 10개의 UTXO를 모아 1비트코인을 만든 것과, 하나의 UTXO로 1비트코인을 만든 경우 가치는 같다. (다만 거래 수수료에서 전자가 손해를 볼 수 있다.)


 


### 코인베이스 거래

- 입력값은 없지만 출력값만 존재하는 거래 
- 블록 내의 첫 번째 거래로 첫 거래는 채굴에 성공한 채굴자에 의해 성성되며 채굴에 대한 보상으로 해당 채굴자에게 지불 가능한 비트코인을 생성한다. 

 


### 거래 출력값 

- 모든 비트코인 거래는 출력값을 생성하며 출력값은 비트코인 장부에 기록된다.
- 한가지 경우(OP_RETURN)을 제외하고, 출력값 대부분은 UTXO를 생성한다.
- 모든 풀 노드는 메모리에 담겨있는 UTXO 풀의 모든 UTXO를 추적할 수 있고 신규거래는 UTXO 풀에서 나온 UTXO를 하나 이상 사용한다. 

 


### 거래 출력값의 구조

| 크기     | 필드               | 설명                                                 |
| -------- | ------------------ | ---------------------------------------------------- |
| 8 Byte   | 총액               | 사토시 단위로 표현되는 비트코인 가치                 |
| 1~9 Byte | 잠금 스크립트 크기 | 따라 나오는 바이트 단위의 잠금 스크립트 길이         |
| 가변적   | 잠금 스크립트      | 출력값을 소비하는 데 필요한 조건을 규정하는 스크립트 |

 

### 거래 입력값	

- 거래 입력값은 특정 UTXO를 거래의 해시와 일련번호를 이용해 지정한다. 
- **해당 UTXO의 잠금 스크립트를 해제할 해제 스크립트도 포함되어야 하며 이것이 해당 UTXO의 소유권을 입증하는 방식이다.**
- 이를 보통 공개키 기반의 서명을 제시함으로써 해결한다. 

 


### 거래 스크립트와 스크립트 언어

- UTXO에 위치한 잠금 스크립트와 대게는 서명이 담겨 있는 해제 스크립트 모두 스크립트 언어로 작성되어 있다.
- 거래가 유효화 될 때 입력값 각각에 들어 있는 해제 스크립트는 소비 조건을 만족하는지 여부를 알아보기 위해 대응 되는 잠금 스크립트와 함께 실행된다. 
- 대부분은 단순한 Pay-to-Public-Key-Hash 스크립트와 같은 간단한 구조지만 더 복잡한 소비조건 또한 표현이 가능하다. 

 


### 스크립팅 언어

- 스택 기반의 실행 언어
- **튜링 불완전성** : 스크립트 언어는 조건부 흐름 제어기능 외에 루프나 복잡한 흐름제어 능력을 가지고 있지 않기 때문에 복잡성이 제한되고 실행 시간이 예측 가능하다. 이러한 제한성 때문에 'logic bomb' 같은 형태를 만들 수 없다. 
- **무상태성** : 언어 내에서는 스크립트 실행 전 혹은 실행 후에 저장되는 상태가 없다. 곧 스크립트를 실행하는 데 필요한 모든 정보는 스크립트 내에 담겨 있으므로 어떤 시스템에서든 예측 가능하며 동일한 방식으로 실행된다. 
- 왼쪽에서 오른쪽으로 실행되는 순서를 가지며 실제 동작관련 예제는 아래와 같음

  

![](https://github.com/bitcoinbook/bitcoinbook/raw/develop/images/mbc2_0604.png)

 

### 표준 거래 

- Pay-to-Public-Key-Hash(P2PKH)
- Pay-to-Public-Key
- 다중 서명 
- 데이터 출력(OP_RETURN)
- Pay-to-Script-Hash(P2SH)




여러가지의 거래 유형이 있고 충분히 따로 공부해 볼 만한 주제들(특히 다중 서명의 경우 그렇다)이지만 나중에 따로 포스팅을 하도록 하고 가장 간단한 Pay-to-Public-Key 스크립트가 어떻게 되는지만 여기에 정리해 두려고 합니다.

  

- 잠금 스크립트: `Public Key A: OP_CHECKSIG`

- 해제 스크립트: `Signature from Public Key A`



이렇게 구성된 두 스크립트를 잠금 || 해제 순으로 연결한 복합 스크립트는 다음과 같은 과정을 거쳐 검증된다.   

![](https://github.com/bitcoinbook/bitcoinbook/raw/develop/images/mbc2_0605.png)

  이렇게 실행된 복합스크립트의 결과가 TRUE 인 경우 해당 Transaction은 정당한 거래로 인정받는다. 

   

## 거래 수수료

### 거래 수수료의 필요성

- 거래 수수료는 모든 거래에 소액의 비용을 부과함으로써 마이닝에 대한 동기부여의 역할 뿐만 아니라 스팸 거래의 동기상실의 역할도 한다. 
- **거래 수수료는 비트코인 단위로 표현되는 거래 가치보다는 KB 단위의 거래 크기를 근거로 계산된다.**
- 수수료는 시장원리에 따라 결정되며 채굴자는 수수료 등 여러 기준에 따라 거래의 우선순위를 정하게 된다. 
- 거래 수수료는 의무사항은 아니지만 수수료가 포함되어 있으면 우선적으로 거래가 처리 될 가능성이 높아진다. 

  


#### 거래에 수수료 추가하기 

- 거래의 데이터 구조에는 수수료 필드가 없다.
- 입력값의 총합과 출력값의 총합의 차이가 곧 수수료다. 
- 거래상 생기는 잔액은 수수료로 지불하지 않으려면 출력값에 명시를 해야한다. 

  


#### 거래 사슬과 고아거래 

- 입력값과 출력값이 엮여 거래는 사슬의 형태를 띄고 있다. (부모, 자식, 손자에 비유할 수 있음)
- 그러나 거래 사슬이 네트워크상에서 전송될 때 항상 순서대로 도착하는 것은 아니며, 때로는 자식 거래를 먼저 전송받을 수 있다. 
- 이런 부모거래가 없는 자식 거래들을 저장해 둘 고아거래 풀이 존재한다.
  - 부모 거래가 도착하면 고아거래는 누구나 풀에서 돌아와 재유효화 될 수 있다. 
  - DoS 공격을 예방하기 위해 메모리에 저장될 고아거래 건수는 제한되어 있음

