<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>network on raeperd.github.io</title>
    <link>https://raeperd.github.io/tags/network/</link>
    <description>Recent content in network on raeperd.github.io</description>
    <image>
      <url>https://raeperd.github.io/papermod-cover.png</url>
      <link>https://raeperd.github.io/papermod-cover.png</link>
    </image>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Fri, 23 Jul 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://raeperd.github.io/tags/network/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>OAuth Basic</title>
      <link>https://raeperd.github.io/notes/network/oauth/</link>
      <pubDate>Fri, 23 Jul 2021 00:00:00 +0000</pubDate>
      
      <guid>https://raeperd.github.io/notes/network/oauth/</guid>
      <description>WEB2 - OAuth 2.0 : 1.수업소개 - YouTube
용어정리  User is Resource Owner My Service is Client Resource Server  Google, Facebook, Twitter   Authorization Server  등록 Resource Ownwer 의 승인  Resource Owner 가 URL 로 접근하면, Resource Server가 이 요청의 유효성을 검사한다. 특정 권한을 허용할 것인지에 대해 Resource Owner 가 승인한다.  Resource Server의 승인  Resource Server 는 응답에 authorization code 를 포함시켜 사용자를 redirection 시킨다.</description>
    </item>
    
    <item>
      <title>OpenID Connect vs Oauth</title>
      <link>https://raeperd.github.io/notes/network/openid-connect-vs-oauth/</link>
      <pubDate>Fri, 23 Jul 2021 00:00:00 +0000</pubDate>
      
      <guid>https://raeperd.github.io/notes/network/openid-connect-vs-oauth/</guid>
      <description>OpenID Connect - OAuth 2.0 Simplified  OAuth 2.0 does not provide a mechanism to say who a user is or how they authenticated, it just says that a user delegated an application to act on their behalf. OpenID Connect takes the OAuth 2.0 framework and adds an identity layer on top. It provides information about the user, as well as enables clients to establish login sessions.  Authorization vs Authentication - OAuth 2.</description>
    </item>
    
    <item>
      <title>Introduction to Troubleshooting and the Future of the Networking</title>
      <link>https://raeperd.github.io/notes/network/introduction-to-troubleshooting-and-the-future-of-the-networking/</link>
      <pubDate>Fri, 26 Jun 2020 00:00:00 +0000</pubDate>
      
      <guid>https://raeperd.github.io/notes/network/introduction-to-troubleshooting-and-the-future-of-the-networking/</guid>
      <description>INTRO 네트워크의 많은 레이어에서 에러를 감지하고 수정하려는 노력을 하지만, 여전히 네트워크 환경에서 오류는 빈번하게 일어난다. 이런 오류들을 발견했을때 어떻게 trouble shooting을 잘 하는가도 개발자로서 중요한 역량이 될 것이다.
CONETNS Verifying Connectivity Ping: Internet Control Message Protocol ICMP(Internet Control Message Protocol)  TCP/IP에서 IP 패킷을 처리할 때 발생되는 문제를 알리거나, 진단 등과 같이 IP 계층에서 필요한 기타 기능들을 수행하기위해 사용되는 프로토콜 IP와 하나의 쌍을 이루면서 동작한다. Data section에는 IP header와 Data payload 의 첫 8바이트가 저장되어있다.</description>
    </item>
    
    <item>
      <title>Network Services</title>
      <link>https://raeperd.github.io/notes/network/network-services/</link>
      <pubDate>Sun, 21 Jun 2020 00:00:00 +0000</pubDate>
      
      <guid>https://raeperd.github.io/notes/network/network-services/</guid>
      <description>INTRO 기초가 참 힘들다. 뭐든지 기초가 참 힘든거 같다. 퇴근하고 공부하는게 참 힘든일이긴 한데 그냥 코딩하는거면 어떻게든 재미를 찾을 수 있을 것 같은데 기초 공부라는게 되게 지루하다. 농구선수가 운동장 달리고 푸쉬업 하는 것처럼 기초는 중요하지만 귀찮고 재미없고 따분하기만 하다. 그래도 해야지 뭐 하면서 또 하게 된다. 잘 좀 하자.
CONETNS Name Resolution Why do we need DNS? 우리가 접속해야하는 사이트마다 IP 주소를 기억해야 한다고 생각하면 참 귀찮을 것이다. 사람들은 숫자를 기억하는 것보다 단어를 더 잘 기억한다.</description>
    </item>
    
    <item>
      <title>The Transport and Application Layer</title>
      <link>https://raeperd.github.io/notes/network/the-transport-and-application-layer/</link>
      <pubDate>Mon, 01 Jun 2020 00:00:00 +0000</pubDate>
      
      <guid>https://raeperd.github.io/notes/network/the-transport-and-application-layer/</guid>
      <description>INTRO 이제까지 배운 Network Layer 까지의 내용으로는 네트워크 상의 하나의 노드에서 다른 노드로의 통신이 어떤 원리로 이루어지는지 확인할 수 있었다. 그러나 실제로 전달되는 정보를 사용하는 것은 네트워크 기기 안에서 동작하는 프로그램들이며, 특정 프로그램이 요청한 정보는 해당 프로그램에 전달되도록 보장되어야 한다. 크롬 브라우저가 보낸 요청을 워드 프로세스가 받으면 곤란할 것 !
이렇게 프로그램 간의 통신은 어떻게 이루어지는지 확인하지 못했는데, 이제부터 다뤄볼 Transport Layer와 Application Layer에서 이를 확인 할 수 있다. 어떻게 보면 이것이 컴퓨터 네트워크의 최종적인 목적이라 할 수 있다.</description>
    </item>
    
    <item>
      <title>The Network Layer</title>
      <link>https://raeperd.github.io/notes/network/the-network-layer/</link>
      <pubDate>Tue, 19 May 2020 00:00:00 +0000</pubDate>
      
      <guid>https://raeperd.github.io/notes/network/the-network-layer/</guid>
      <description>CIDR (Classless Inter-Domain Routing) Address class를 이용해 IP 주소를 잘 나눌 수 있었다. Subnetting은 Address class로 나누어진 network 를 기존의 규칙을 유지하면서 네트워크를 더 작게 분할할 수 있게 해줬다. 그런데 인터넷이 더 커지면서 Subnetting 도 충분하지 않게 되었다.
254 개의 호스트를 사용할 수 있는 class C 네트워크 보다는 많고 65534 개의 호스트를 사용할 수 있는 class B 네트워크는 너무 많다고 느껴지면 어떻게 할까? class C 네트워크 여러 개를 사용하는 방법이 있다.</description>
    </item>
    
    <item>
      <title>The Basics of Networking Devices</title>
      <link>https://raeperd.github.io/notes/network/the-basics-of-networking-devices/</link>
      <pubDate>Wed, 13 May 2020 00:00:00 +0000</pubDate>
      
      <guid>https://raeperd.github.io/notes/network/the-basics-of-networking-devices/</guid>
      <description>프로그래밍을 하다가 네트워크 관련 문제가 발생했을 때 꼭 원인이 프로그램에 있다고 단정 지을 수는 없다. 여러가지 요인이 있을 수 있겠지만 당연하게도 하드웨어가 문제가 있을 수도 있다. 전문가 만큼은 아니더라도 간단하게 나마 어떤 하드웨어가 어떤 역할을 하는지 정도는 정리해둬서 나쁠게 없다.
Cables Copper cable  전압의 변화로 0, 1을 구분할 수 있다. 케이블이 보통 한쌍이 엮여있는 형태인데 가장 보편적인 형태가 Cat5, Cat5e, Cat6 이다. 내부의 케이블이 어떻게 구성되어있냐에 따라 데이터의 전송 속도나 안정성에 영향을 미친다.</description>
    </item>
    
    <item>
      <title>Internet Protocol</title>
      <link>https://raeperd.github.io/notes/network/internet-protocol/</link>
      <pubDate>Tue, 12 May 2020 00:00:00 +0000</pubDate>
      
      <guid>https://raeperd.github.io/notes/network/internet-protocol/</guid>
      <description>LAN 에서는 MAC 으로 기기간의 통신을 할 수 있다. 그런데 MAC 은 구조적으로 정렬된 주소는 아니다. 모든 네트워크 기기는 고유한 MAC 주소를 가지고 있지만, 특정 시점에 특정 MAC 주소를 가지는 기기가 지구상의 어디에 존재하는지는 알 방법이 없다. 분명히, 멀리 있는 기기간의 통신에서는 다른 종류의 해답이 필요하고, 이 문제를 3번째 Layer인 Network Layer에서 Internet Protocol 을 이용해 해결할 수 있다.
IP Address 4 byte 구성된 주소
 IP addresses belong to networks, not to the devices attached to those network</description>
    </item>
    
    <item>
      <title>Subnetting</title>
      <link>https://raeperd.github.io/notes/network/subnetting/</link>
      <pubDate>Tue, 12 May 2020 00:00:00 +0000</pubDate>
      
      <guid>https://raeperd.github.io/notes/network/subnetting/</guid>
      <description>큰 네트워크를 작은 네트워크로 나누는 과정 잘못된 서브넷 셋업이 많이들 실수하는 것이라 제대로 이해하고 넘어가는게 좋다.  Address class는 IP 주소가 가질 수 있는 주소를 의미있게 구분할 수 있다. 만약 9.100.100.100 주소와 통신하고 싶다면, 인터넷 상의 core router는 9.100.100.100 주소가 9.0.0.0 class A 네트워크에 속한다는 것을 알 수 있다. 이후 core router는 이 메세지를 gateway router 에게 전달하는데 이 router 가 특정 네트워크의 입구이자 출구 역할을 한다.
그런데 다시 앞에서 배웠던 IP Address class를 생각해보면, class A 네트워크가 가질 수 있는 호스트는 생각보다 너무 많다.</description>
    </item>
    
    <item>
      <title>TCP/IP 5 Layer Model</title>
      <link>https://raeperd.github.io/notes/network/tcp-ip-5-layer-model/</link>
      <pubDate>Tue, 12 May 2020 00:00:00 +0000</pubDate>
      
      <guid>https://raeperd.github.io/notes/network/tcp-ip-5-layer-model/</guid>
      <description>보통 OSI Seven-Layer 모델과 함께 가장 많이 언급되는 모델이다. 여기서 모델이라 함은, 컴퓨터 네트워크가 어떻게 구성되어있는지를 설명하는 방법에 지나지 않는다. TCP/IP Five-Layer 모델과 OSI Seven-Layer 모델은 같은 대상을 조금 다르게 설명할 뿐 하고자 하는 일은 같다. 강의에서 TCP/IP Five-Layer 모델을 주로 하기 때문에 앞으로도 이 내용으로 정리하고자 한다.
￼ Physical Layer  케이블의 연결이나 전원 같은 물리적으로 데이터를 전송하는 계층  Data Link Layer  a.k.a. Network Interface Layer or Network Access Layer Physical layer 의 기능들을 공통의 인터페이스로 추상화하는 단계 서로 다른 네트워크 기기들이 신호를 해석할 수 있는 약속, 프로토콜이 필요한 첫번째 Layer다.</description>
    </item>
    
    <item>
      <title>The Data Link Layer</title>
      <link>https://raeperd.github.io/notes/network/the-data-link-layer/</link>
      <pubDate>Tue, 12 May 2020 00:00:00 +0000</pubDate>
      
      <guid>https://raeperd.github.io/notes/network/the-data-link-layer/</guid>
      <description>최근에 대부분의 네트워크 기기들이 무선 연결을 사용하지만 데이터 센터와 같은 곳에서는 여전이 유선 연결을 사용한다. 유선으로 연결한 대부분의 네트워크 장비들은 Ethernet 프로토콜을 따른다.
Data-Link-Layer의 가장 주된 목적은 Physical-Layer의 구체적인 구현에 대해 추상화를 하는 것이다.
Ethernet and MAC Address Ethernet  CSMA / CD (Carrier sense multiple access with collision detection)  통신 채널이 언제 사용가능한지 확인하고 가능할때만 데이터를 전송하게 한다. 채널에 데이터가 전송되고 있지 않으면 노드는 데이터를 보낸다. 어떤 컴퓨터가 데이터를 보내고 있다면 이를 확인하고 데이터를 보내지 않는다.</description>
    </item>
    
  </channel>
</rss>
